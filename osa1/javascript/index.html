<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-content-template-js.bb6688043828bda42216.css">@import url(https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,500,600);.course{position:relative}.course h1,.course h2,.course h3,.course h4,.course p{margin-left:3rem;padding-bottom:2rem}.course pre{margin:2rem 0;background-color:#33332d;color:#fff}.course img{border:11px solid transparent}.course a{border:0;border-bottom:2px;border-style:solid;border-color:transparent;padding:2px}.course .banner,.course .container{position:static}.course .letter{width:4rem;height:4rem;border-width:5px;border-style:solid;border-radius:2.5rem;text-align:center;margin:1rem;line-height:.8em}@media (min-width:640px){.course .letter{-webkit-transform:translate(-3rem,5rem);transform:translate(-3rem,5rem)}}.course .letter,.course h1{font-size:3.444rem;font-weight:700}.course li{list-style-type:none}.course li:before{content:"-";margin-right:1rem}.arrow__container{position:relative}.arrow__container:not():first-child{border-left:none}.arrow__container:not():first-child:before{content:"";background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NzcuMTc1IDQ3Ny4xNzUiPjxwYXRoIGQ9Ik0zNjAuNzMxIDIyOS4wNzVsLTIyNS4xLTIyNS4xYy01LjMtNS4zLTEzLjgtNS4zLTE5LjEgMHMtNS4zIDEzLjggMCAxOS4xbDIxNS41IDIxNS41LTIxNS41IDIxNS41Yy01LjMgNS4zLTUuMyAxMy44IDAgMTkuMSAyLjYgMi42IDYuMSA0IDkuNSA0IDMuNCAwIDYuOS0xLjMgOS41LTRsMjI1LjEtMjI1LjFjNS4zLTUuMiA1LjMtMTMuOC4xLTE5eiIvPjwvc3ZnPg==) no-repeat;background-size:contain;position:absolute;top:0;left:0;height:100%;width:100%}.arrows--horizontal{display:flex;position:relative;margin:0;align-items:flex-start}.arrow__wrapper{display:flex;justify-content:flex-start;align-items:center;margin:0}.arrow__wrapper:first-of-type{border-right:none;z-index:20}.arrow__wrapper:nth-of-type(n+2){margin-left:-4rem;z-index:10}.arrow__wrapper:nth-of-type(n+2) .arrow__rectangle{border-left:none;padding-left:4rem}.arrow__wrapper:nth-of-type(3){z-index:5}.arrow__rectangle{padding:1rem;justify-content:center;align-items:center;border:2px solid #33332d;border-right:none;z-index:2;overflow:hidden}.arrow__rectangle .bold{font-weight:600}.arrow__rectangle--thick-border{border:3px solid #33332d;border-right:none}.arrow__point{padding:1.25rem;border:2px solid #33332d;border-bottom:none;border-left:none;-webkit-transform:translate(-1.3rem) rotate(45deg);transform:translate(-1.3rem) rotate(45deg);z-index:1;overflow:hidden}.arrow__point--thick-border{border:3px solid #33332d;border-bottom:none;border-left:none}.arrow__wrapper--stacked{display:flex;justify-content:flex-start;align-items:center;margin:auto auto auto 0}.arrow__wrapper--stacked:nth-of-type(n+2){margin-top:-2px}.arrow--stacked-letter{margin-right:2rem}.arrow--stacked-title{text-transform:uppercase;white-space:nowrap}.arrow__container--with-link{width:100%!important}.element--flex{display:flex;flex-wrap:wrap}.element--space-around{justify-content:space-around}.element--space-between{justify-content:space-between}.element--column{flex-direction:column}.element--centered{align-items:center}.element--horizontal-half{width:45%}.element--auto-bottom-margin{margin-bottom:auto}.element--flex-start{align-content:flex-start}.banner{display:flex;align-items:center;position:relative;padding:2.22rem 0;background-color:#e1e1e1}@media (min-width:992px){.banner{padding:3.444rem 3.444rem 4.444rem}}html{font-family:IBM Plex Mono,monospace;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:IBM Plex Mono,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em IBM Plex Mono,monospace;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:IBM Plex Mono,monospace;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}body,html{margin:0;padding:0;font-family:IBM Plex Mono,monospace;font-weight:500;color:#33332d;font-size:14px;line-height:1.555rem}@media (min-width:992px){body,html{font-size:18px}}body{padding-top:120px}@media (min-width:992px){body{padding-top:90px}}p{margin:0;text-align:left;line-height:1.5em}a,p{color:#33332d}a{text-decoration:none}.container{position:relative;margin:0 auto;display:flex;flex-wrap:wrap;justify-content:space-between;width:90%;max-width:1200px}.hidden{display:none!important}.centered{text-align:center}.spacing{margin-top:2.22rem}@media (min-width:992px){.spacing{margin-top:5.55rem}}.spacing--small{margin-top:1.11rem}@media (min-width:992px){.spacing--small{margin-top:3.444rem}}.spacing--large{margin-top:4.44rem}@media (min-width:992px){.spacing--large{margin-top:11.1rem}}.spacing--extra-large{margin-top:4.44rem}@media (min-width:992px){.spacing--extra-large{margin-top:22.2rem}}.spacing--after{margin-bottom:2.22rem}@media (min-width:992px){.spacing--after{margin-bottom:5.55rem}}.spacing--after-small{margin-bottom:1.11rem}@media (min-width:992px){.spacing--after-small{margin-bottom:2.775rem}}.spacing--after-large{margin-bottom:4.44rem}@media (min-width:992px){.spacing--after-large{margin-bottom:11.1rem}}@media (max-width:991px){.spacing--mobile{margin-top:2.22rem}}.col-1{width:100%}@media (min-width:992px){.col-1{width:10%}}.col-2{width:100%}@media (min-width:992px){.col-2{width:20%}}.col-3{width:100%}@media (min-width:992px){.col-3{width:30%}}.col-4{width:100%}@media (min-width:992px){.col-4{width:40%}}.col-5{width:100%}@media (min-width:992px){.col-5{width:50%}}.col-6{width:100%}@media (min-width:992px){.col-6{width:60%}}.col-7{width:100%}@media (min-width:992px){.col-7{width:70%}}.col-8{width:100%}@media (min-width:992px){.col-8{width:80%}}.col-9{width:100%}@media (min-width:992px){.col-9{width:90%}}.col-10{width:100%}@media (min-width:992px){.col-10{width:100%}}@media (min-width:992px){.push-right-1{margin-left:10%}.push-right-2{margin-left:20%}.push-right-3{margin-left:30%}.push-right-4{margin-left:40%}.push-right-5{margin-left:50%}.push-left-1{margin-right:10%}.push-left-2{margin-right:20%}.push-left-3{margin-right:30%}.push-left-4{margin-right:40%}.push-left-5{margin-right:50%}.push-left{margin-right:auto}.push-right{margin-left:auto}}@media (max-width:991px){.col-5--mobile{width:50%}.col-10--mobile{width:100%}.order-0--mobile{order:0}.order-1--mobile{order:1}.order-2--mobile{order:2}.order-3--mobile{order:3}.order-4--mobile{order:4}.order-5--mobile{order:5}.hidden--mobile{display:none}}.centered-vertically{display:flex;flex-direction:column;justify-content:center}.nav-item-hover{font-size:1.111rem;font-weight:600;text-decoration:none;color:#33332d;padding:.2em}.nav-item-hover:active,.nav-item-hover:focus,.nav-item-hover:hover{color:#fff;background-color:#33332d}.nav-item-hover:active,.nav-item-hover:focus{outline:2px solid #706be4}.flex-fix-aligning:after,.flex-fix-aligning:before{content:"";width:30%;order:2}#footer .nav-item-hover{font-size:.777rem;font-weight:500}.triple-border{margin:5px;position:relative;padding:2px;border-radius:5px 0;transition:color .1s ease-in-out,background-color .1s ease-in-out}.triple-border:after,.triple-border:before{content:"";border:2px solid #33332d;border-radius:5px;position:absolute;width:calc(100% + 5px);height:calc(100% + 5px)}.triple-border:before{left:0;top:0}.triple-border:after{bottom:0;right:0}.triple-border__container{overflow:hidden;border-radius:3px 0}.triple-border--large-margin{margin:13px;padding:3px}.triple-border--large-margin:after,.triple-border--large-margin:before{content:"";border-width:3px;border-radius:13px;width:calc(100% + 13px);height:calc(100% + 13px)}.triple-border--large-margin .triple-border__container{border-radius:10px 0}.triple-border__logo{padding:.2rem;font-size:1.111rem;font-weight:600}.triple-border__return-tasks{font-size:.9rem;padding:1rem .2rem}.body-text:not(:last-of-type){margin-bottom:2.775rem}.body-text__title{color:#33332d;font-size:1.44rem;line-height:1.25em;font-weight:700;margin:0;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.body-text__content:not(:last-of-type){padding-bottom:2em}.bold{font-weight:700}.body-text--no-padding{padding:0!important}.scroll-navigation li:hover{cursor:pointer;background-color:#000;color:#fff}.sub-header{color:#33332d;font-family:IBM Plex Mono,monospace;padding-bottom:1.357rem}@media (min-width:992px){.sub-header{padding-bottom:2.333rem}}</style><meta name="generator" content="Gatsby 2.0.53"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link as="script" rel="preload" href="/component---src-templates-content-template-js-1511b04e7342894ff772.js"/><link as="script" rel="preload" href="/2-a8e181bf0eaee510a2de.js"/><link as="script" rel="preload" href="/app-ea23b7086a93b0204497.js"/><link as="script" rel="preload" href="/webpack-runtime-5db535bfaadb9bdad9b8.js"/><link rel="preload" href="/static/d/882/path---osa-1-javascript-59-c-88f-GYjSanASlU3pt2Yq2xYEOCbv8jw.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div><div class="container" style="align-items:center"><a style="text-decoration:none" href="/"><div class="triple-border nav-item-hover " style="padding:0.2em"><div class="triple-border__container triple-border__logo" style="background-color:transparent">{() =&gt; fs}</div></div></a><div class="col-4 push-left-4" style="display:flex;justify-content:space-between;font-weight:bold"><a class="nav-item-hover" href="/about">KURSSISTA</a><a class="nav-item-hover" href="/faq">FAQs</a><a class="nav-item-hover" href="/companies">YRITYSESITTELYT</a></div></div><div class="spacing--small spacing--after"><div class="course-container"><div class="banner spacing--after" style="background-image:url(/static/osa1-b7ac07cbe6df8ed745701fabe73af8ef.png);background-position:center center;background-size:80%;background-repeat:no-repeat;background-color:#AEFFDA"><div class="container"><div class="col-10 spacing spacing--after"><div class="arrow__container arrows--horizontal"><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:#AEFFDA;color:black">YLEISTÄ</div><div class="arrow__point " style="background-color:#AEFFDA;color:black"></div></div><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:#AEFFDA;color:black">OSA 1 YLEISTÄ</div><div class="arrow__point " style="background-color:#AEFFDA;color:black"></div></div><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:black;color:white">JAVASCRIPT</div><div class="arrow__point " style="background-color:black;color:white"></div></div></div></div></div></div><div class="course"><div class="container"><div class="col-7 course-content push-right-3" style="border-color:#AEFFDA"><p class="col-1 letter" style="border-color:#AEFFDA">b</p><h1 class="sub-header ">Javascript</h1></div></div><div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<p>Kurssin aikana on websovelluskehityksen rinnalla tavoite ja tarve oppia riittävässä määrin Javascriptiä.</p>
<p>Javascript on kehittynyt viime vuosina nopeaan tahtiin, ja käytämme kurssilla kielen uusimpien versioiden piirteitä, joista osa ei ole vielä edes ehtinyt kielen viimeisimpään standardoituun versioon. Javascript-standardin virallinen nimi on <a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a>. Tämän hetken tuorein versio on kesäkuussa 2017 julkaistu <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">ES8</a>, toiselta nimeltään ECMAScript 2017.</p>
<p>Selaimet eivät vielä osaa kaikkia Javascriptin uusimpien versioiden ominaisuuksia. Tämän takia selaimessa suoritetaan useimmiten koodia joka on käännetty (englanniksi <em>transpiled</em>) uudemmasta Javascriptin versiosta johonkin vanhempaan, laajemmin tuettuun versioon.</p>
<p>Tällä hetkellä johtava tapa tehdä transpilointi on <a href="https://babeljs.io/">Babel</a>. Create-react-app:in avulla luoduissa React-sovelluksissa on valmiiksi konfiguroitu automaattinen transpilaus. Katsomme kurssin <a href="/osa7">osassa 7</a> tarkemmin miten transpiloinnin konfigurointi tapahtuu.</p>
<p><a href="https://nodejs.org/en/">Node.js</a> on melkein missä vaan, mm. palvelimilla toimiva, Googlen <a href="https://developers.google.com/v8/">chrome V8</a>-javascriptmoottoriin perustuva Javascript-suoritusympäristö. Harjoitellaan hieman Javascriptiä Nodella. Tässä oletetaan, että koneellasi on Node.js:stä vähintään versio <em>v8.6.0</em>. Noden tuoreet versiot osaavat suoraan Javascriptin uusia versioita, joten koodin transpilaus ei ole tarpeen.</p>
<p>Koodi kirjoitetaan <em>.js-</em>päätteiseen tiedostoon, ja suoritetaan komennolla <code>node tiedosto.js</code></p>
<p>Koodia on mahdollisuus kirjoittaa myös Node.js-konsoliin, joka aukeaa kun kirjoitat komentorivillä <em>node</em> tai myös selaimen developer toolin konsoliin. Chromen uusimmat versiot osaavat suoraan transpiloimatta <a href="http://kangax.github.io/compat-table/es6/">melko hyvin</a> Javascriptin uusiakin piirteitä.</p>
<p>Javascript muistuttaa nimensä ja syntaksinsa puolesta läheisesti Javaa. Perusmekanismeiltaan kielet kuitenkin poikkeavat radikaalisti. Java-taustalta tultaessa Javascriptin käyttäytyminen saattaa aiheuttaa hämmennystä, varsinkin jos kielen piirteistä ei viitsitä ottaa selvää.</p>
<p>Tietyissä piireissä on myös ollut suosittua yrittää &quot;simuloida&quot; Javascriptilla eräitä Javan piirteitä ja ohjelmointitapoja. En suosittele.</p>
<h3>Muuttujat</h3>
<p>Javascriptissä on muutama tapa määritellä muuttujia:</p>
<pre><code class="language-js">const x = 1;
let y = 5;

console.log(x, y); // tulostuu 1, 5
y += 10;
console.log(x, y); // tulostuu 1, 15
y = &#x27;teksti&#x27;;
console.log(x, y); // tulostuu 1, teksti
x = 4; // aiheuttaa virheen
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">const</a> ei oikeastaan määrittele muuttujaa vaan <em>vakion</em>, jonka arvoa ei voi enää muuttaa. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">let</a> taas määrittelee normaalin muuttujan.</p>
<p>Esimerkistä näemme myös, että muuttujan tallettaman tiedon tyyppi voi vaihtaa tyyppiä suorituksen aikana, <em>y</em> tallettaa aluksi luvun ja lopulta merkkijonon.</p>
<p>Javascriptissa on myös mahdollista määritellä muuttujia avainsanan <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">var</a> avulla. Var oli pitkään ainoa tapa muuttujien määrittelyyn, const ja let tulivat kieleen mukaan vasta versiossa ES6. Var toimii tietyissä tilanteissa <a href="https://medium.com/craft-academy/javascript-variables-should-you-use-let-var-or-const-394f7645c88f">eri</a> <a href="http://www.jstips.co/en/javascript/keyword-var-vs-let/">tavalla</a> kuin useimpien muiden kielien muuttujien määrittely. Tällä kurssilla varin käyttö ei ole suositeltavaa eli käytä aina const:ia tai let:iä!</p>
<p>Lisää aiheesta esim. youtubessa <a href="https://youtu.be/sjyJBL5fkp8">var, let and const - ES6 JavaScript Features</a></p>
<h3>Taulukot</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Taulukko</a> ja muutama esimerkki sen käytöstä</p>
<pre><code class="language-js">const t = [1, -1, 3];

t.push(5);

console.log(t.length); // tulostuu 4
console.log(t[1]); // tulostuu -1

t.forEach(luku =&gt; {
  console.log(luku); // tulostuu 1, -1, 3 ja 5 omille riveilleen
});

t[6] = 99;

console.log(t); // tulostuu [ 1, -1, 3, 5, &lt;2 empty items&gt;, 99 ]
</code></pre>
<p>Huomattavaa esimerkissä on se, että taulukon sisältöä voi muuttaa vaikka sen on määritelty <em>const</em>:ksi. Koska taulukko on olio,
viittaa muuttuja koko ajan samaan olioon. Olion sisältö muuttuu sitä mukaa kuin taulukkoon lisätään uusia alkioita.</p>
<p>Eräs tapa käydä taulukon alkiot läpi on esimerkissä käytetty <em>forEach</em>, joka saa parametrikseen nuolisyntaksilla määritellyn <em>funktion</em></p>
<pre><code class="language-js">luku =&gt; {
  console.log(luku);
};
</code></pre>
<p>forEach kutsuu funktiota <em>jokaiselle taulukon alkiolle</em> antaen taulukon alkion aina parametrina. forEachin parametrina oleva funktio voi saada myös <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">muita parametreja</a>.</p>
<p>Taulukoille on määritelty runsaasti hyödyllisiä operaatioita. Katsotaan pieni esimerkki operaation <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> käytöstä.</p>
<pre><code class="language-js">const t = [1, 2, 3, 4];

const m1 = t.map(luku =&gt; luku * 2);
console.log(m1); // tulostuu [2, 4, 6, 8]

const m2 = t.map(luku =&gt; &#x27;&lt;li&gt;&#x27; + luku + &#x27;&lt;/li&gt;&#x27;);
console.log(m2); // tulostuu [ &#x27;&lt;li&gt;1&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;2&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;3&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;4&lt;/li&gt;&#x27; ]
</code></pre>
<p>Map siis muodostaa taulukon perusteella <em>uuden taulukon</em>, jonka jokainen alkio muodostetaan map:in parametrina olevan funktion avulla. Kuten tulemme kurssin <a href="/osa2">osassa2</a> näkemään, mapia käytetään Reactissa todella usein.</p>
<p>Taulukon yksittäisiä alkioita on helppo sijoittaa muuttujiin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destrukturoivan</a> sijoituslauseen avulla:</p>
<pre><code class="language-js">const t = [1, 2, 3, 4, 5];

const [eka, toka, ...loput] = t;

console.log(eka, toka); // tulostuu 1, 2
console.log(loput); // tulostuu [3, 4 ,5]
</code></pre>
<p>Eli muuttujiin <em>eka</em> ja <em>toka</em> tulee sijoituksen ansiosta taulukon kaksi ensimmäistä lukua. Muuttujaan <em>loput</em> &quot;kerätään&quot; sijoituksesta jäljellejääneet luvut omaksi taulukoksi.</p>
<h3>Oliot</h3>
<p>Javasriptissa on muutama tapa määritellä olioita. Erittäin yleisesti käytetään <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals">olioliteraaleja</a>, eli määritellään olio luettelemalla sen kentät (englanniksi property) aaltosulkeiden sisällä:</p>
<pre><code class="language-js">const olio1 = {
  nimi: &#x27;Arto Hellas&#x27;,
  ika: 35,
  koulutus: &#x27;Filosofian tohtori&#x27;,
};

const olio2 = {
  nimi: &#x27;Full Stack -websovelluskehitys&#x27;,
  taso: &#x27;aineopinto&#x27;,
  laajuus: 5,
};

const olio3 = {
  nimi: {
    etunimi: &#x27;Jami&#x27;,
    sukunimi: &#x27;Kousa&#x27;,
  },
  arvosanat: [2, 3, 5, 3],
  laitos: &#x27;TKTL&#x27;,
};
</code></pre>
<p>Kenttien arvot voivat olla tyypiltään mitä vaan, lukuja, merkkijonoja, taulukoita, olioita...</p>
<p>Olioiden kenttiin viitataan pistenotaatiolla, tai hakasulkeilla:</p>
<pre><code class="language-js">console.log(olio1.nimi); // tulostuu Arto Hellas
const kentanNimi = &#x27;ika&#x27;;
console.log(olio1[kentanNimi]); // tulostuu 35
</code></pre>
<p>Olioille voidaan lisätä kenttiä myös lennossa joko pistenotaation tai hakasulkeiden avulla:</p>
<pre><code class="language-js">olio1.osoite = &#x27;Tapiola&#x27;;
olio1[&#x27;salainen numero&#x27;] = 12341;
</code></pre>
<p>Jälkimmäinen lisäyksistä on pakko tehdä hakasulkeiden avulla, sillä pistenotaatiota käytettäessä &#x27;salainen numero&#x27; ei kelpaa kentän nimeksi.</p>
<p>Javascriptissä olioilla voi luonnollisesti olla myös metodeja. Palaamme aiheeseen funktioiden käsittelyn jälkeen.</p>
<p>Olioita on myös mahdollista määritellä ns. konstruktorifunktioiden avulla, jolloin saadaan aikaan hieman monien ohjelmointikielten, esim. Javan luokkia (class) muistuttava mekanismi. Javascriptissä ei kuitenkaan ole luokkia samassa mielessä kuin olio-ohjelmointikielissä. Kieleen on kuitenkin lisätty versiosta ES6 alkaen <em>luokkasyntaksi</em>, joka helpottaa tietyissä tilanteissa olio-ohjelmointikielimäisten luokkien esittämistä. Palaamme asiaan hetken kuluttua.</p>
<p>Reactissa konstruktorifunktioihin perustuvalle olioiden määrittelylle ei ole kovin usein tarvetta, joten sivuutamme sen tällä kurssilla.</p>
<h3>Funktiot</h3>
<p>Olemme jo tutustuneet ns. nuolifunktioiden määrittelyyn. Täydellinen eli &quot;pitkän kaavan&quot; mukaan menevä tapa nuolifunktion määrittelyyn on seuraava</p>
<pre><code class="language-js">const summa = (p1, p2) =&gt; {
  console.log(p1);
  console.log(p2);
  return p1 + p2;
};
</code></pre>
<p>ja funktiota kutsutaan kuten olettaa saattaa</p>
<pre><code class="language-js">const vastaus = summa(1, 5);
console.log(vastaus);
</code></pre>
<p>Jos parameteja on vain yksi, voidaan sulut jättää määrittelystä pois:</p>
<pre><code class="language-js">const nelio = p =&gt; {
  console.log(p);
  return p * p;
};
</code></pre>
<p>Jos funktio sisältää ainoastaan yhden lausekkeen, ei aaltosulkeita tarvita. Tällöin funktio palauttaa ainoan lausekkeensa arvon. Eli edellinen voitaisiin ilmaista lyhyemmin seuraavasti:</p>
<pre><code class="language-js">const nelio = p =&gt; p * p;
</code></pre>
<p>Tämä muoto on erityisen kätevä käsiteltäessä taulukkoja esim. map-metodin avulla:</p>
<pre><code class="language-js">const t = [1, 2, 3];
const tnelio = t.map(p =&gt; p * p);
// tnelio on nyt [1, 4, 9]
</code></pre>
<p>Nuolifunktio on tullut Javascriptiin vasta muutama vuosi sitten version <a href="http://es6-features.org/">ES6</a> myötä. Tätä ennen ja paikoin nykyäänkin funktioiden määrittely tapahtui avainsanan <em>function</em> avulla.</p>
<p>Määrittelytapoja on kaksi, funktiolle voidaan antaa <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">function declaration</a> -tyyppisessä määrittelyssä <em>nimi</em> jonka avulla funktioon voidaan viitata:</p>
<pre><code class="language-js">function tulo(a, b) {
  return a * b;
}

const vastaus = tulo(2, 6);
</code></pre>
<p>Toinen tapa on tehdä määrittely <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function">funktiolausekkeena</a>. Tällöin funktiolle ei tarvitse antaa nimeä ja määrittely voi sijaita muun koodin seassa:</p>
<pre><code class="language-js">const keskiarvo = function(a, b) {
  return (a + b) / 2;
};

const vastaus = keskiarvo(2, 5);
</code></pre>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#AEFFDA"><div class="container"><div class="course-content col-7 push-right-3">
  <h3>Tehtävät 1.3</h3>
  <h4>tieto olioissa</h4>
<p>Siirrytään käyttämään sovelluksessamme oliota. Muuta <em>App</em>:in muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikkia osia niin, että se taas toimii:</p>
<pre><code class="language-react">const App = () =&gt; {
  const kurssi = &#x27;Half Stack -sovelluskehitys&#x27;
  const osa1 = {
    nimi: &#x27;Reactin perusteet&#x27;,
    tehtavia: 10
  }
  const osa2 = {
    nimi: &#x27;Tiedonvälitys propseilla&#x27;,
    tehtavia: 7
  }
  const osa3 = {
    nimi: &#x27;Komponenttien tila&#x27;,
    tehtavia: 14
  }

  return (
    &lt;div&gt;
      ...
    &lt;/div&gt;
  )
}
</code></pre>
  <h3>Tehtävät 1.4</h3>
  <h4>oliot taulukkoon</h4>
<p>Ja laitetaan oliot taulukkoon, eli muuta <em>App</em>:in muuttujamäärittelyt seuraavaan muotoon ja muuta sovelluksen kaikki osat vastaavasti:</p>
<pre><code class="language-react">const App = () =&gt; {
  const kurssi = &#x27;Half Stack -sovelluskehitys&#x27;
  const osat = [
    {
      nimi: &#x27;Reactin perusteet&#x27;,
      tehtavia: 10
    },
    {
      nimi: &#x27;Tiedonvälitys propseilla&#x27;,
      tehtavia: 7
    },
    {
      nimi: &#x27;Komponenttien tila&#x27;,
      tehtavia: 14
    }
  ]

  return (
    &lt;div&gt;
      ...
    &lt;/div&gt;
  )
}
</code></pre>
<p><strong>HUOM:</strong> tässä vaiheessa <em>voit olettaa, että taulukossa on aina kolme alkiota</em>, eli taulukkoa ei ole pakko käydä läpi looppaamalla. Palataan taulukossa olevien olioiden perusteella tapahtuvaan komponenttien renderöintiin asiaan tarkemmin kurssin <a href="../osa2">seuraavassa osassa</a>.</p>
<p>Älä kuitenkaan välitä eri olioita komponenttien välillä (esim. komponentista <em>App</em> komponenttiin <em>Yhteensa</em>) erillisinä propsina, vaan suoraan taulukkona:</p>
<pre><code class="language-react">const App = () =&gt; {
  // const-määrittelyt

  return (
    &lt;div&gt;
      &lt;Otsikko kurssi={kurssi} /&gt;
      &lt;Sisalto osat={osat} /&gt;
      &lt;Yhteensa osat={osat} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
  <h3>Tehtävät 1.5</h3>
  <h4>jako komponenteiksi</h4>
<p>Viedään muutos vielä yhtä askelta pidemmälle, eli tehdään kurssista ja sen osista yksi Javascript-olio. Korjaa kaikki mikä menee rikki.</p>
<pre><code class="language-react">const App = () =&gt; {
  const kurssi = {
    nimi: &#x27;Half Stack -sovelluskehitys&#x27;,
    osat: [
      {
        nimi: &#x27;Reactin perusteet&#x27;,
        tehtavia: 10
      },
      {
        nimi: &#x27;Tiedonvälitys propseilla&#x27;,
        tehtavia: 7
      },
      {
        nimi: &#x27;Komponenttien tila&#x27;,
        tehtavia: 14
      }
    ]
  }

  return (
    &lt;div&gt;
      ...
    &lt;/div&gt;
  )
}
</code></pre>
</div></div></div>
<div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h3>Olioiden metodit ja this</h3>
<p>Kaikille kolmelle tavalle määritellä funktio on oma paikkansa.</p>
<p>Nuolifunktiot ja avainsanan <em>function</em> avulla määritellyt funktiot kuitenkin poikkeavat radikaalisti siitä miten ne käyttäytyvät avainsanan <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this</a> suhteen.</p>
<p>Voimme liittää oliolle metodeja määrittelemällä niille kenttiä, jotka ovat funktioita:</p>
<pre><code class="language-js">const arto = {
  nimi: &#x27;Arto Hellas&#x27;,
  ika: 35,
  koulutus: &#x27;Filosofian tohtori&#x27;,
  tervehdi: function() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  },
};

arto.tervehdi(); // tulostuu hello, my name is Arto Hellas
</code></pre>
<p>metodeja voidaan liittää olioille myös niiden luomisen jälkeen:</p>
<pre><code class="language-js">const arto = {
  nimi: &#x27;Arto Hellas&#x27;,
  ika: 35,
  koulutus: &#x27;Filosofian tohtori&#x27;,
  tervehdi: function() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  },
};

arto.vanhene = function() {
  this.ika += 1;
};

console.log(arto.ika); // tulostuu 35
arto.vanhene();
console.log(arto.ika); // tulostuu 36
</code></pre>
<p>Muutetaan oliota hiukan</p>
<pre><code class="language-js">const arto = {
  nimi: &#x27;Arto Hellas&#x27;,
  tervehdi: function() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  },
  laskeSumma: function(a, b) {
    console.log(a + b);
  },
};

arto.laskeSumma(1, 4); // tulostuu 5

const viiteSummaan = arto.laskeSumma;
viiteSummaan(10, 15); // tulostuu 25
</code></pre>
<p>Oliolla on nyt metodi <em>laskeSumma</em>, joka osaa laskea parametrina annettujen lukujen summan. Metodia voidaan kutsua normaaliin tapaan olion kautta <code>arto.laskeSumma(1, 4)</code> tai tallettamalla <em>metodiviite</em> muuttujaan ja kutsumalla metodia muuttujan kautta <code>viiteSummaan(10, 15)</code>.</p>
<p>Jos yritämme samaa metodille <em>tervehdi</em>, aiheutuu ongelmia:</p>
<pre><code class="language-js">const arto = {
  nimi: &#x27;Arto Hellas&#x27;,
  tervehdi: function() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  },
  laskeSumma: function(a, b) {
    console.log(a + b);
  },
};

arto.tervehdi(); // tulostuu hello, my name is Arto Hellas

const viiteTervehdykseen = arto.tervehdi;
viiteTervehdykseen(); // tulostuu hello, my name is undefined
</code></pre>
<p>Kutsuttaessa metodia viitteen kautta, on metodi kadottanut tiedon siitä mikä oli alkuperäinen <em>this</em>. Toisin kuin melkein kaikissa muissa kielissä, Javascriptissa <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this</a>:n arvo määrittyy sen mukaan <em>miten metodia on kutsuttu</em>. Kutsuttaessa metodia viitteen kautta, <em>this</em>:in arvoksi tulee ns. <a href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object">globaali objekti</a> ja lopputulos ei ole yleensä ollenkaan se, mitä sovelluskehittäjä olettaa.</p>
<p>This:in kadottaminen aiheuttaa Reactilla ja Node.js:lla ohjelmoidessa monia potentiaalisia ongelmia. Eteen tulee erittäin usein tilanteita, missä Reactin/Noden (oikeammin ilmaistuna selaimen Javascript-moottorin) tulee kutsua joitain käyttäjän määrittelemien olioiden metodeja. Tälläinen tilanne tulee esim. jos pyydetään Artoa tervehtimään sekunnin kuluttua metodia <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">setTimeout</a> hyväksikäyttäen.</p>
<pre><code class="language-js">const arto = {
  nimi: &#x27;Arto Hellas&#x27;,
  tervehdi: function() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  },
};

setTimeout(arto.tervehdi, 1000);
</code></pre>
<p>Javascriptissa this:in arvo siis määräytyy siitä miten metodia on kutsuttu. setTimeoutia käytettäessä metodia kutsuu Javascript-moottori ja this viittaa Timeout-olioon.</p>
<p>On useita mekanismeja, joiden avulla alkuperäinen <em>this</em> voidaan säilyttää, eräs näistä on metodin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a> käyttö:</p>
<pre><code class="language-js">setTimeout(arto.tervehdi.bind(arto), 1000);
</code></pre>
<p>Komento <code>arto.tervehdi.bind(arto)</code> luo uuden funktion, missä se on sitonut <em>this</em>:in tarkoittamaan Artoa riippumatta siitä missä ja miten metodia kutsutaan.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Nuolifunktioiden</a> avulla on mahdollista ratkaista eräitä this:iin liittyviä ongelmia. Olioiden metodeina niitä ei kuitenkaan kannata käyttää, sillä silloin <em>this</em> ei toimi ollenkaan. Palaamme nuolifunktioiden this:in käyttäytymiseen myöhemmin.</p>
<p>Jos haluat ymmärtää paremmin javascriptin <em>this</em>:in toimintaa, löytyy internetistä runsaasti materiaalia aiheesta. Esim. <a href="https://egghead.io">egghead.io</a>:n 20 minuutin screencastsarja <a href="https://egghead.io/courses/understand-javascript-s-this-keyword-in-depth">Understand JavaScript&#x27;s this Keyword in Depth</a> on erittäin suositeltava!</p>
<h3>Luokat</h3>
<p>Kuten aiemmin mainittiin, Javascriptissä ei ole olemassa olio-ohjelmointikielten luokkamekanismia. Javascriptissa on kuitenkin ominaisuuksia, jotka mahdollistavat olio-ohjelmoinnin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">luokkien</a> &quot;simuloinnin&quot;. Emme mene nyt sen tarkemmin Javascriptin olioiden taustalla olevaan <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">prototyyppiperintämekanismiin</a>.</p>
<p>Tutustumme kuitenkin pikaisesti ES6:n myötä Javascriptiin tulleeseen <em>luokkasyntaksiin</em>, joka helpottaa oleellisesti luokkien (tai luokan kaltaisten asioiden) määrittelyä Javascriptissa.</p>
<p>Seuraavassa on määritelty &quot;luokka&quot; Henkilö ja sille kaksi Henkilö-oliota:</p>
<pre><code class="language-js">class Henkilo {
  constructor(nimi, ika) {
    this.nimi = nimi;
    this.ika = ika;
  }
  tervehdi() {
    console.log(&#x27;hello, my name is&#x27;, this.nimi);
  }
}

const arto = new Henkilo(&#x27;Arto Hellas&#x27;, 35);
arto.tervehdi();

const jami = new Henkilo(&#x27;Jami Kousa&#x27;, 21);
jami.tervehdi();
</code></pre>
<p>Syntaksin osalta luokat ja niistä luodut oliot muistuttavat erittäin paljon esim. Javan olioita. Käyttäytymiseltäänkin ne ovat aika lähellä Javan olioita. Perimmiltään kyseessä on kuitenkin edelleen Javascriptin <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance">prototyyppiperintään</a> perustuvista olioista. Molempien olioiden todellinen tyyppi on <em>Object</em> sillä Javascriptissä ei perimmiltään ole muita tyyppejä kuin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">Boolean, Null, Undefined, Number, String, Symbol ja Object</a></p>
<p>Luokkasyntaksin tuominen Javascriptiin on osin kiistelty lisäys, ks. esim. <a href="https://github.com/joshburgess/not-awesome-es6-classes">Not Awesome: ES6 Classes</a> tai <a href="https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65">Is “Class” In ES6 The New “Bad” Part?</a></p>
<p>ES6:n luokkasyntaksia käytetään kuitenkin paljon Reactissa ja Node.js:ssä ja siksi mekin käytämme sitä sopivissa määrin. Olio-ohjelmointimainen luokkahierarkioiden luominen ei kuitenkaan ole Reactin eikä tämän kurssin suositeltavan hengen mukaista. Reactia ohjelmoitaessa pyritään enemmän funktionaaliseen ohjelmointityyliin.</p>
<h3>Javascript-materiaalia</h3>
<p>Javascriptistä löytyy verkosta suuret määrät sekä hyvää että huonoa materiaalia. Tällä sivulla lähes kaikki Javascriptin ominaisuuksia käsittelevät linkit ovat <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Mozillan javascript -materiaaliin</a>.</p>
<p>Mozillan sivuilta kannattaa lukea oikeastaan välittömästi <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript">A re-introduction to JavaScript (JS tutorial)</a>.</p>
<p>Jos haluat tutustua todella syvällisesti Javascriptiin, löytyy internetistä ilmaiseksi mainio kirjasarja <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a></p>
<p><a href="https://egghead.io">egghead.io</a>:lla on tarjolla runsaasti laadukkaita screencasteja Javascriptista, Reactista ym. kiinnostavasta. Valitettavasti materiaali on osittain maksullista.</p>
<h2>Paluu Reactin äärelle</h2>
<p>Palataan jälleen Reactin pariin.</p>
<p>Aiemmassa esimerkissämme käytimme <a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components">funktionaalisia</a> komponentteja, eli määrittelimme kaikki komponentit nuolifunktioiden avulla, esim:</p>
<pre><code class="language-react">const Hello = (props) =&gt; {
  return (
    &lt;div&gt;
      &lt;p&gt;Hello {props.name}, you are {props.age} years old&lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Toinen tapa komponenttien määrittelyyn on käyttää luokkasyntaksia. Tällöin komponentti määritellään luokaksi, joka perii <a href="https://reactjs.org/docs/react-component.html">React.Component</a>-luokan.</p>
<p>Muutetaan esimerkkisovelluksen komponentti <em>Hello</em> -luokaksi seuraavasti:</p>
<pre><code class="language-react">class Hello extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Hello {this.props.name}, you are {this.props.age} years old&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Luokkakomponenttien tulee määritellä ainakin metodi <em>render</em>, joka palauttaa komponentin ulkoasun määrittelevät React-elementit eli käytännössä JSX:n.</p>
<p>Luokkakomponentissa viitataan komponentin <em>propseihin</em> this-viitteen kautta.
Eli koska komponenttia käytetään seuraavasti</p>
<pre><code class="language-html">&lt;Hello name=&quot;Arto&quot; age={36} /&gt;
</code></pre>
<p>päästään nimeen ja ikään käsiksi luokkamuotoisen komponentin sisällä viittaamalla <em>this.props.name</em> ja <em>this.props.age</em>. Huomaa ero funktionaaliseen komponenttiin!</p>
<p>Luokkakomponenteille voidaan tarvittaessa määritellä muitakin metodeja ja &quot;oliomuuttujia&quot;, eli kenttiä.</p>
<p>Voisimme esim. määritellä metodin seuraavasti:</p>
<pre><code class="language-react">class Hello extends React.Component {
  bornYear() {
    const yearNow = new Date().getFullYear()
    return yearNow - this.props.age
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;
          Hello {this.props.name}, you are {this.props.age} years old &lt;br /&gt;
          So you were probably born {this.bornYear()}
        &lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Metodia kutsutaan render:in sisältä käyttäen <em>this</em>-viitettä syntaksilla <code>this.bornYear()</code>.</p>
<p>Tässä tilanteessa ei kuitenkaan ole varsinaisesti mitään hyötyä määritellä apufunktiota <em>bornYear</em> metodiksi, joten parempi olisi määritellä se metodin <em>render</em> sisäisenä apumetodina:</p>
<pre><code class="language-react">class Hello extends React.Component {
  render() {
    const bornYear = () =&gt; {
      const yearNow = new Date().getFullYear()
      return yearNow - this.props.age
    }

    return (
      &lt;div&gt;
        &lt;p&gt;
          Hello {this.props.name}, you are {this.props.age} years old &lt;br /&gt;
          So you were probably born {bornYear()}
        &lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Huomaa, että nyt metodia <em>ei</em> kutsuta viitteen <em>this</em> kautta, vaan syntaksilla <code>bornYear()</code>, sillä metodi ei ole komponentin eli <em>this</em>:in tasolla määritelty. Metodia <em>bornYear</em> ei nyt voi kutsua mistään muualta kuin metodin <em>render</em> sisältä, sillä se ei näy renderin ulkopuolelle.</p>
<p>Ennen kuin siirrymme eteenpäin, tarkastellaan erästä pientä, mutta käyttökelpoista ES6:n mukanaan tuomaa uutta piirrettä Javascriptissä, eli sijoittamisen yhteydessä tapahtuvaa <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destrukturointia</a>.</p>
<p>Jouduimme äskeisessä koodissa viittaamaan propseina välitettyyn dataan hieman ikävästi muodossa <em>this.props.name</em> ja <em>this.props.age</em>. Näistä <em>this.props.age</em> pitää toistaa metodissa <em>render</em> kahteen kertaan.</p>
<p>Koska <em>this.props</em> on nyt olio</p>
<pre><code class="language-js">this.props = {
  name: &#x27;Arto Hellas&#x27;,
  age: 35,
};
</code></pre>
<p>voimme suoraviivaistaa metodia <em>render</em> siten, että sijoitamme kenttien arvot muuttujiin <em>name</em> ja <em>age</em> jonka jälkeen niitä on mahdollista käyttää koodissa suoraan:</p>
<pre><code class="language-react">render() {
  const name = this.props.name
  const age = this.props.age
  const bornYear = () =&gt; new Date().getFullYear() - age

  return (
    &lt;div&gt;
      &lt;p&gt;
        Hello {name}, you are {age} years old &lt;br /&gt;
        So you were probably born {bornYear()}
      &lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Huomaa, että olemme myös hyödyntäneet nuolifunktion kompaktimpaa kirjoitustapaa metodin <em>bornYear</em> määrittelyssä.</p>
<p>Destrukturointi tekee asian vielä helpommaksi, sen avulla voimme &quot;kerätä&quot; olion oliomuuttujien arvot suoraan omiin yksittäisiin muuttujiin:</p>
<pre><code class="language-react">class Hello extends React.Component {
  render() {
    const {name, age} = this.props
    const bornYear = () =&gt; new Date().getFullYear() - age

    return (
      &lt;div&gt;
        &lt;p&gt;
          Hello {name}, you are {age} years old &lt;br /&gt;
          So you were probably born {bornYear()}
        &lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Eli koska</p>
<pre><code class="language-js">this.props = {
  name: &#x27;Arto Hellas&#x27;,
  age: 35,
};
</code></pre>
<p>saa <code> const {name, age} = this.props</code> aikaan sen, että <em>name</em> saa arvon &#x27;Arto Hellas&#x27; ja <em>age</em> arvon 35.</p>
<p>Komponentti <em>Hello</em> on oikeastaan luonteeltaan sellainen, että sitä ei ole järkevää määritellä luokkasyntaksilla. Reactin best practice onkin käyttää funktioiden avulla määriteltyjä komponentteja aina kuin mahdollista.</p>
<h3>Sivun uudelleenrenderöinti</h3>
<p>Toistaiseksi tekemämme sovellukset ovat olleet sellaisia, että kun niiden komponentit on kerran renderöity, niiden ulkoasua ei ole enää voinut muuttaa. Entä jos haluaisimme toteuttaa laskurin, jonka arvo kasvaa esim. ajan kuluessa tai nappien painallusten yhteydessä?</p>
<p>Aloitetaan seuraavasta rungosta:</p>
<pre><code class="language-react">const App = (props) =&gt; {
  const {counter} = props
  return (
    &lt;div&gt;{counter.value}&lt;/div&gt;
  )
}

const counter = {
  value: 1
}

ReactDOM.render(
  &lt;App counter={counter} /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Sovelluksen juurikomponentille siis annetaan viite laskuriin. Juurikomponentti renderöi arvon ruudulle. Entä laskurin arvon muuttuessa? Jos lisäämme ohjelmaan esim. komennon</p>
<pre><code class="language-react">counter.value += 1
</code></pre>
<p>ei komponenttia kuitenkaan renderöidä uudelleen. Voimme saada komponentin uudelleenrenderöitymään kutsumalla uudelleen metodia <em>ReactDOM.render</em>, esim. seuraavasti</p>
<pre><code class="language-react">const App = (props) =&gt; {
  const {counter} = props
  return (
    &lt;div&gt;{counter.value}&lt;/div&gt;
  )
}

const counter = {
  value: 1
}

const renderoi = () =&gt; {
  ReactDOM.render(
    &lt;App counter={counter} /&gt;,
    document.getElementById(&#x27;root&#x27;)
  )
}

renderoi()
counter.value += 1
renderoi()
counter.value += 1
renderoi()
</code></pre>
<p>Copypastea vähentämään on komponentin renderöinti kääritty funktioon <em>renderoi</em>.</p>
<p>Nyt komponentti renderöityy kolme kertaa, saaden ensin arvon 1, sitten 2 ja lopulta 3. 1 ja 2 tosin ovat ruudulla niin vähän aikaa, että niitä ei ehdi havaita.</p>
<p>Hieman mielenkiintoisempaan toiminnallisuuteen pääsemme tekemällä renderöinnin ja laskurin kasvatuksen toistuvasti sekunnin välein käyttäen <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">SetInterval</a>:</p>
<pre><code class="language-js">setInterval(() =&gt; {
  renderoi();
  counter.value += 1;
}, 1000);
</code></pre>
<p><em>ReactDOM.render</em>-metodin toistuva kutsuminen ei kuitenkaan ole suositeltu tapa päivittää komponentteja. Tutustutaan seuraavaksi järkevämpään tapaan.</p>
<h3>Tilallinen komponentti</h3>
<p>Muutetaan esimerkkisovelluksen komponentti <em>App</em> luokkaperustaiseksi:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      counter: 1
    }
  }

  render() {
    return (
      &lt;div&gt;{this.state.counter}&lt;/div&gt;
    )
  }
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Komponentilla on nyt metodin <em>render</em> lisäksi <em>konstruktori</em>. Komponentin konstruktori saa parametrikseen sille välitettävät muuttujat parametrin <em>props</em> välityksellä, konstruktorin ensimmäisen rivin on oltava kutsu <code>super(props)</code>.</p>
<p>Luokkiin perustuvilla komponenteilla voi olla <em>tila</em>, joka talletetaan muuttujaan <em>state</em>.</p>
<p>Konstruktori määrittelee komponentin alkutilan olevan:</p>
<pre><code class="language-js">{
  counter: 1;
}
</code></pre>
<p>Eli tila sisältää kentän <em>counter</em>, jonka arvo on 1. React-komponenttien tilaa, eli muuttujaa <em>this.state</em> <strong>ei saa päivittää suoraan</strong>, tilan päivitys on tehtävä <strong>aina</strong> funktion <a href="https://reactjs.org/docs/faq-state.html#what-does-setstate-do">setState</a> avulla. Metodin kutsuminen päivittää tilan <em>ja</em> aiheuttaa komponentin uuden renderöinnin (ellei sitä ole estetty myöhemmin esiteltävällä tavalla). Uudelleenrenderöinnin yhteydessä myös kaikki komponentin sisältämät alikomponentit renderöidään.</p>
<p>Muutetaan komponenttia <em>App</em> siten, että konstruktorissa käynnistetään ajastin, joka kutsuu funktiota <em>setState</em> toistuvasti sekunnin välein korottaen laskurin arvoa aina yhdellä:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }

    setInterval(() =&gt; {
      this.setState({ counter: this.state.counter + 1 })
    }, 1000)
  }
  render() {
    return (
      &lt;div&gt;{this.state.counter}&lt;/div&gt;
    )
  }
}
</code></pre>
<p>Ruudulle renderöity laskurin arvo päivittyy sillä aina komponentin tilan muuttuessa <em>React</em> kutsuu komponentin metodia <em>render</em>.</p>
<p>Jos komponentti ei renderöidy vaikka sen omasta mielestä pitäisi, tai se renderöityy &quot;väärään aikaan&quot;, debuggaamista auttaa joskus metodiin <em>render</em> liitetty konsoliin tulostus. Esim. jos lisäämme koodiin seuraavan,</p>
<pre><code class="language-react">class App extends React.Component {
  // ...
  render() {
    console.log(&#x27;renderöidään&#x27;, this.state.counter)
    return (
      &lt;div&gt;{this.state.counter}&lt;/div&gt;
    )
  }
}
</code></pre>
<p>on konsolista helppo seurata metodin <em>render</em> kutsuja:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/5a2248873f442ef831d6561303c99b41/14be6/27a.png"/></picture>
<h3>Tapahtumankäsittely</h3>
<p>Mainitsimme jo <a href="/osa0">osassa 0</a> muutamaan kertaan <em>tapahtumankäsittelijät</em>, eli funktiot, jotka on rekisteröity kutsuttavaksi tiettyjen tapahtumien eli eventien yhteydessä. Esim. käyttäjän interaktio sivun elementtien kanssa aiheuttaa joukon erinäisiä tapahtumia.</p>
<p>Muutetaan sovellusta siten, että laskurin kasvaminen tapahtuukin käyttäjän painaessa <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button">button</a>-elementin avulla toteutettua nappia.</p>
<p>Button-elementit tukevat mm. <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">hiiritapahtumia</a> (mouse events), joista yleisin on <a href="https://developer.mozilla.org/en-US/docs/Web/Events/click">click</a>.</p>
<p>Reactissa funktion rekisteröiminen tapahtumankäsittelijäksi tapahtumalle <em>click</em> <a href="https://reactjs.org/docs/handling-events.html">tapahtuu</a> seuraavasti:</p>
<pre><code class="language-react">const funktio = () =&gt; { /* koodi */ }

//...

&lt;button onClick={funktio}&gt;
  plus
&lt;/button&gt;
</code></pre>
<p>Eli laitetaan <em>button</em>:in onClick-attribuutin arvoksi aaltosulkeissa oleva viite koodissa määriteltyyn funktioon.</p>
<p>Tapahtumankäsittelijäfunktio voidaan määritellä suoraan onClick-määrittelyn yhteydessä:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.state.counter}&lt;/div&gt;
        &lt;button onClick={() =&gt; console.log(&#x27;clicked&#x27;)}&gt;
          plus
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Nyt jokainen napin <em>plus</em> painallus tulostaa konsoliin <em>clicked</em>.</p>
<p>Muuttamalla tapahtumankäsittelijä seuraavaan muotoon</p>
<pre><code class="language-bash">&lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })}&gt;
  plus
&lt;/button&gt;
</code></pre>
<p>saamme halutun toiminnallisuuden.</p>
<p>Lisätään sovellukseen myös nappi laskurin nollaamiseen:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.state.counter}&lt;/div&gt;
        &lt;div&gt;
          &lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })}&gt;
            plus
          &lt;/button&gt;
          &lt;button onClick={() =&gt; this.setState({ counter: 0 })}&gt;
            zero
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Sovelluksemme on valmis!</p>
<h3>Metodien käyttö ja <em>this</em></h3>
<p>Tapahtumankäsittelijöiden määrittely suoraan JSX-templatejen sisällä ei useimmiten ole kovin viisasta. Eriytetään nappien tapahtumankäsittelijät omiksi metodeikseen:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
  }

  kasvataYhdella() {
    this.setState({ counter: this.state.counter + 1 })
  }

  nollaa() {
    this.setState({ counter: 0 })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.state.counter}&lt;/div&gt;
        &lt;div&gt;
          &lt;button onClick={this.kasvataYhdella}&gt;
            plus
          &lt;/button&gt;
          &lt;button onClick={this.nollaa}&gt;
            zero
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Komponentin määrittelemälle luokalle on nyt lisätty metodit <em>kasvataYhdella</em> ja <em>nollaa</em>. Metodeihin <em>viitataan</em> nappeja vastaavista React-elementeistä:</p>
<pre><code class="language-jsx">&lt;button onClick={this.kasvataYhdella}&gt;
</code></pre>
<p>Kun testaamme nyt sovellusta, törmäämme ongelmaan. Virheilmoitus on erittäin hyvä:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/619813ceac00763e0059edcb67000297/14be6/28.png"/></picture>
<p>Eli törmäämme jo <a href="#olioiden-metodit-ja-this">aiemmin mainittuun</a> ongelmaan alkuperäisen <em>this</em>:in kadottamisesta.</p>
<p>Kun selaimen Javascriptin runtime kutsuu takaisinkutsufunktiota, <em>this</em> ei enää viittaa komponenttiin <em>App</em> vaan on arvoltaan <em>undefined</em> eli määrittelemätön:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/1d47fd8edd2312f959c103151e0db442/14be6/29.png"/></picture>
<p>Ongelmaan on useita erilaisia ratkaisuja. Eräs näistä on jo <a href="#olioiden-metodit-ja-this">aiemmin mainittu</a> <em>bindaaminen</em>, eli esim. komennolla <code>this.kasvataYhdella.bind(this)</code> voimme muodostaa uuden funktion, jonka koodi on alkuperäisen funktion koodi, missä <em>this</em> on sidottu viittaamaan parametrina olevaan arvoon, eli komponenttiin itseensä.</p>
<p>Eli sovellus toimii taas jos koodi muutetaan muotoon:</p>
<pre><code class="language-html">&lt;button onClick=&quot;{this.kasvataYhdella.bind(this)}&quot;&gt;plus&lt;/button&gt;
&lt;button onClick=&quot;{this.nollaa.bind(this)}&quot;&gt;zero&lt;/button&gt;
</code></pre>
<p>Jos samaa metodia joudutaan kutsumaan useasta kohtaa koodia, on hieman ikävää kirjoittaa toistuvasti metodin bindattu muoto React-elementtien sekaan.</p>
<p>Yksi mahdollisuus onkin suorittaa bindaukset konstruktorissa:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
    this.kasvataYhdella = this.kasvataYhdella.bind(this)
    this.nollaa = this.nollaa.bind(this)
  }
</code></pre>
<p>Nyt riittää viitata metodeihin &quot;normaalisti&quot;, ilman bindiä:</p>
<pre><code class="language-html">&lt;button onClick=&quot;{this.kasvataYhdella}&quot;&gt;plus&lt;/button&gt;
&lt;button onClick=&quot;{this.nollaa}&quot;&gt;zero&lt;/button&gt;
</code></pre>
<p>Teknisesti ottaen konstruktorissa korvataan kenttään <em>kasvataYhdella</em> alunperin määritelty metodi uudella metodilla, jolla on alkuperäisen metodin koodi siten, että <em>this</em> on pysyvästi bindattu komponenttiin.</p>
<p>Ehkä paras ratkaisu <em>this</em>-ongelman estämiseen on käyttää tulevaan Javascript-standardiin ehdotettua <a href="https://babeljs.io/docs/plugins/transform-class-properties/">class properties</a> -ominaisuutta, jonka avulla voimme määritellä this:in suhteen hyvin käyttäytyviä metodeja seuraavasti:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
  }

  kasvataYhdella = () =&gt; {
    this.setState({ counter: this.state.counter + 1 })
  }

  nollaa = () =&gt; {
    this.setState({ counter: 0 })
  }

  render() {
    // ...
  }
</code></pre>
<p>Näin jokainen <em>App</em>-komponentti saa kentät <em>kasvataYhdella</em> ja <em>nollaa</em> jotka ovat funktioita, joiden <em>this</em> on sidottu komponenttiin riippumatta siitä miten ja kenen toimesta metodia kutsutaan.</p>
<p>Syy miksi nuolifunktiolla määritelty metodi toimii <em>this</em>:in suhteen samaan tapaan kuin esim. Javassa, on se, että nuolifunktioilla on ns. <em>leksikaalinen (lexical) this</em>, eli nuolifunktion <em>this</em> määräytyy sen määrittelykontekstin <em>this</em>:in mukaan. Kun metodi määritellään class propertynä, on määrittelykontekstina <em>App</em>-komponentti. Tarkempaa selitystä esim. <a href="https://medium.com/@reasoncode/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4">täällä</a>.</p>
<p>Käytämme kurssilla jatkossa tätä tapaa komponenttien metodien määrittelemiseen.</p>
<p><a href="https://babeljs.io/docs/plugins/transform-class-properties/">class propertyt</a> siis eivät ole vielä mukana uusimmassa javascript-standardissa eli kesäkuussa 2017 ilmestyneessä ES8:ssa. Voimme kuitenkin käyttää ominaisuutta create-react-app:illa luoduissa sovelluksissa, sillä <a href="https://babeljs.io/">babel</a> osaa kääntää (eli transpiloida) ominaisuuden selainten ymmärtämään muotoon.</p>
<p>Node.js ei oletusarvoisesti vielä tue ominaisuutta, eli kääntämätöntä koodia joka sisältää class propertyjä ei voi vielä suorittaa Node.js:llä.</p>
<h3>Pari huomiota funktion setState käytöstä</h3>
<p>Käytimme metodia <em>setState</em> kahteen kertaan:</p>
<pre><code class="language-js">kasvataYhdella = () =&gt; {
  this.setState({ counter: this.state.counter + 1 });
};

nollaa = () =&gt; {
  this.setState({ counter: 0 });
};
</code></pre>
<p>Näistä ensimmäinen tapa <code>this.setState({ counter: this.state.counter + 1 })</code> ei ole kaikissa tilanteissa suositeltava, sillä React ei takaa että metodin <em>setState</em> kutsut tapahtuvat <a href="https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous">siinä järjestyksessä missä ne on kirjoitettu koodiin</a>.</p>
<p>Jos halutaan määritellä uusi tila olemassaolevan tilan perusteella, on varmempi kutsua <em>setState</em>:a seuraavasti:</p>
<pre><code class="language-js">this.setState(prevState =&gt; ({
  counter: prevState.counter + 1,
}));
</code></pre>
<p>Nyt metodin parametrina on funktio, jonka parametrina on edellinen tila <em>prevState</em> ja tilan päivitys tapahtuu varmuudella kutsuhetken edellisen tilan perusteella.</p>
<p>Emme nyt viitsi käyttää tätä monimutkaisempaa muotoa, sillä emme välitä vaikka sovelluksessamme ilmenisikin silloin tällöin pieni epäkonsistenssi (on epäselvää olisiko se sovelluksessamme edes teoriassa mahdollista).</p>
<p>Asia tulee kuitenkin ehdottomasti pitää mielessä, <em>setState</em>:n vääränlainen käyttö saattaa aiheuttaa hankalasti löydettäviä, harvoin toistuvia bugeja.</p>
<p>Tärkeä mielessä pidettävä seikka on myös se, että <strong>React kutsuu funktiota setState asynkroonisesti</strong>, eli jos meillä on seuraava koodi</p>
<pre><code class="language-js">console.log(this.state.counter);
this.setState({ counter: 55 });
console.log(this.state.counter);
</code></pre>
<p>tulostavat molemmat rivit saman arvon sillä Reactin tila <strong>ei saa uutta arvoa</strong> heti komennon <em>this.setState</em> jälkeen, vaan vasta sitten, kun suorituksen alla oleva metodi on suoritettu loppuun ja <em>setState</em> on saanut mahdollisuuden suoritukselle.</p>
<h3>Funktio joka palauttaa funktion</h3>
<p>Metodit <em>kasvataYhdella</em> ja <em>nollaa</em> toimivat melkein samalla tavalla, ne asettavat uuden arvon laskurille. Tehdään koodiin yksittäinen metodi, joka sopii molempiin käyttötarkoituksiin:</p>
<pre><code class="language-react">asetaArvoon = (arvo) =&gt; {
  this.setState({ counter: arvo })
}

render() {
  //...
  &lt;button onClick={this.asetaArvoon(this.state.counter+1)}&gt;
    Plus
  &lt;/button&gt;
  &lt;button onClick={this.asetaArvoon(0)}&gt;
    Zero
  &lt;/button&gt;
  //...
}
</code></pre>
<p>Huomaamme kuitenkin että muutos hajottaa sovelluksemme täysin:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/1216f0a01360b09bc66aedec7f9b6d5e/14be6/30.png"/></picture>
<p>Mistä on kyse? Tapahtumankäsittelijäksi on tarkoitus määritellä viite <em>funktioon</em>. Kun koodissa on</p>
<pre><code class="language-react">&lt;button onClick={this.asetaArvoon(0)}&gt;
</code></pre>
<p>tapahtumankäsittelijäksi tulee määriteltyä <em>funktiokutsu</em>. Sekin on monissa tilanteissa ok, mutta ei nyt, nimittäin kun React suorittaa metodin <em>render</em>, se suorittaa kutsun <code>this.asetaArvoon(0)</code>. Kutsu aiheuttaa metodin <em>setState</em> kutsun. Tämä taas aiheuttaa uuden <em>render</em>-kutsun jne...</p>
<p>Tässä tilanteessa meidän onkin käytettävä yleistä Javascriptin ja yleisemminkin funktionaalisen ohjelmoinnin kikkaa, eli määritellä <em>funktio joka palauttaa funktion</em>:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      counter: 1
    }
  }

  asetaArvoon = (arvo) =&gt; {
    return () =&gt; {
      this.setState({ counter: arvo })
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.state.counter}&lt;/div&gt;
        &lt;div&gt;
          &lt;button onClick={this.asetaArvoon(this.state.counter + 1)}&gt;
            Plus
          &lt;/button&gt;
          &lt;button onClick={this.asetaArvoon(0)}&gt;
            Zero
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Jos et ole aiemmin törmännyt tekniikkaan, siihen totutteluun voi mennä tovi.</p>
<p>Olemme siis määritelleet komponentin metodin <em>asetaArvoon</em> seuraavasti:</p>
<pre><code class="language-js">asetaArvoon = arvo =&gt; {
  return () =&gt; {
    this.setState({ counter: arvo });
  };
};
</code></pre>
<p>Kun <em>render</em>-metodissa määritellään tapahtumankäsittelijä kutsumalla <code>this.asetaArvoon(0)</code>, on lopputuloksena</p>
<pre><code class="language-js">() =&gt; {
  this.setState({ counter: 0 });
};
</code></pre>
<p>eli juuri oikeanlainen tilan nollaamisen aiheuttava funktio!</p>
<p>Plus-napin tapahtumankäsittelijä määritellään kutsumalla <code>this.asetaArvoon(this.state.counter + 1)</code>. Kun komponentti renderöidään ensimmäisen kerran, <em>this.state.counter</em> on saanut konstruktorissa arvon 1, eli plus-napin tapahtumankäsittelijäksi tulee metodikutsun <code>this.asetaArvoon(1 + 1)</code> tulos, eli funktio</p>
<pre><code class="language-js">() =&gt; {
  this.setState({ counter: 2 });
};
</code></pre>
<p>Vastaavasti, kun laskurin tila on esim 41, tulee plus-napin tapahtumakuuntelijaksi</p>
<pre><code class="language-js">() =&gt; {
  this.setState({ counter: 42 });
};
</code></pre>
<p>Tarkastellaan vielä hieman metodia <em>asetaArvoon</em>:</p>
<pre><code class="language-js">asetaArvoon = arvo =&gt; {
  return () =&gt; {
    this.setState({ counter: arvo });
  };
};
</code></pre>
<p>Koska metodi itse sisältää ainoastaan yhden komennon, eli <em>returnin</em>, joka palauttaa funktion, voidaan hyödyntää nuolifunktion tiiviimpää muotoa:</p>
<pre><code class="language-js">asetaArvoon = arvo =&gt; () =&gt; {
  this.setState({ counter: arvo });
};
</code></pre>
<p>Usein tälläisissä tilanteissa kaikki kirjoitetaan samalle riville, jolloin tuloksena on &quot;kaksi nuolta sisältävä funktio&quot;:</p>
<pre><code class="language-js">asetaArvoon = arvo =&gt; () =&gt; this.setState({ counter: arvo });
</code></pre>
<p>Kaksinuolisen funktion voi ajatella funktiona, jota lopullisen tuloksen saadakseen täytyy kutsua kaksi kertaa.</p>
<p>Ensimmäisellä kutsulla &quot;konfiguroidaan&quot; varsinainen funktio, sijoittamalla osalle parametreista arvo. Eli kutsu <code>asetaArvoon(5)</code> sitoo muuttujaan <em>arvo</em> arvon 5 ja funktiosta &quot;jää jäljelle&quot; seuraava funktio:</p>
<pre><code class="language-js">() =&gt; this.setState({ counter: 5 });
</code></pre>
<p>Tässä näytetty tapa soveltaa funktioita palauttavia funktioita on oleellisesti sama asia mistä funktionaalisessa ohjelmoinnissa käytetään termiä <a href="http://www.datchley.name/currying-vs-partial-application/">currying</a>. Termi currying ei ole lähtöisin funktionaalisen ohjelmoinnin piiristä vaan sillä on juuret <a href="https://en.wikipedia.org/wiki/Currying">syvällä matematiikassa</a>.</p>
<p>Jo muutamaan kertaan mainittu termi <em>funktionaalinen ohjelmointi</em> ei ole välttämättä kaikille tässä vaiheessa tuttu. Asiaa avataan hiukan kurssin kuluessa, sillä React tukee ja osin edellyttää funktionaalisen tyylin käyttöä.</p>
<p><strong>HUOM:</strong> muutos, missä korvasimme metodit <em>kasvataArvoa</em> ja <em>nollaa</em> metodilla <em>asetaArvoon</em> ei välttämättä ole järkevä, sillä erikoistuneemmat metodit ovat paremmin nimettyjä. Teimme muutoksen oikeastaan ainoastaan demonstroidaksemme <em>currying</em>-tekniikan soveltamista.</p>
<h3>Tilan vieminen alikomponenttiin</h3>
<p>Reactissa suositaan pieniä komponentteja, joita on mahdollista uusiokäyttää monessa osissa sovellusta ja jopa useissa eri sovelluksissa. Refaktoroidaan koodiamme vielä siten, että yhden komponentin sijaan koostamme laskurin näytöstä ja kahdesta painikkeesta.</p>
<p>Tehdään ensin näytöstä vastaava komponentti <em>Display</em>.</p>
<p>Reactissa parhaana käytänteenä on sijoittaa tila <a href="https://reactjs.org/docs/lifting-state-up.html">mahdollisimman ylös</a> komponenttihierarkiassa, mielellään sovelluksen juurikomponenttiin.</p>
<p>Jätetään sovelluksen tila, eli laskimen arvo komponenttiin <em>App</em> ja välitetään tila <em>props</em>:ien avulla komponentille <em>Display</em>:</p>
<pre><code class="language-react">const Display = (props) =&gt; {
  return (
    &lt;div&gt;{props.counter}&lt;/div&gt;
  )
}
</code></pre>
<p>Kyseessä on siis todella yksinkertainen komponentti joka kannattaa ehdottomasti määritellä funktion avulla eli funktionaalisena komponenttina.</p>
<p>Voimme hyödyntää aiemmin mainittua <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destrukturointia</a> myös metodien parametreissa. Eli koska olemme kiinnostuneita <em>props</em>:in kentästä <em>counter</em>, on edellinen mahdollista yksinkertaistaa seuraavaan muotoon:</p>
<pre><code class="language-react">const Display = ({ counter }) =&gt; {
  return (
    &lt;div&gt;{counter}&lt;/div&gt;
  )
}
</code></pre>
<p>Koska komponentin määrittelevä metodi ei sisällä muuta kuin returnin, voimme ilmaista sen hyödyntäen nuolifunktioiden tiiviimpää ilmaisumuotoa</p>
<pre><code class="language-react">const Display = ({ counter }) =&gt; &lt;div&gt;{counter}&lt;/div&gt;
</code></pre>
<p>Komponentin käyttö on suoraviivaista, riittää että sille välitetään laskurin tila eli <em>this.state.counter</em>:</p>
<pre><code class="language-react">class App extends React.Component {
  // ...
  render() {
    return (
      &lt;div&gt;
        &lt;Display counter={this.state.counter}/&gt;
        &lt;div&gt;
          &lt;button onClick={this.asetaArvoon(this.state.counter+1)}&gt;
            Plus
          &lt;/button&gt;
          &lt;button onClick={this.asetaArvoon(0)}&gt;
            Zero
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Kaikki toimii edelleen. Kun nappeja painetaan ja <em>App</em> renderöityy uudelleen, renderöityvät myös kaikki sen alikomponentit, siis myös <em>Display</em> automaattisesti uudelleen.</p>
<p>Tehdään seuraavaksi napeille tarkoitettu komponentti <em>Button</em>. Napille on välitettävä propsien avulla tapahtumankäsittelijä sekä napin teksti:</p>
<pre><code class="language-react">const Button = (props) =&gt; (
  &lt;button onClick={props.handleClick}&gt;
    {props.text}
  &lt;/button&gt;
)
</code></pre>
<p>ja hyödynnetään taas destrukturointia ottamaan <em>props</em>:in tarpeelliset kentät suoraan:</p>
<pre><code class="language-react">const Button = ({ handleClick, text }) =&gt; (
  &lt;button onClick={handleClick}&gt;
    {text}
  &lt;/button&gt;
)
</code></pre>
<p>Komponentin <em>App</em> metodi <em>render</em> muuttuu nyt muotoon:</p>
<pre><code class="language-react">render() {
  return (
    &lt;div&gt;
      &lt;Display counter={this.state.counter}/&gt;
      &lt;div&gt;
        &lt;Button
          handleClick={this.asetaArvoon(this.state.counter + 1)}
          text=&quot;Plus&quot;
        /&gt;
        &lt;Button
          handleClick={this.asetaArvoon(this.state.counter - 1)}
          text=&quot;Minus&quot;
        /&gt;
        &lt;Button
          handleClick={this.asetaArvoon(0)}
          text=&quot;Zero&quot;
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Koska meillä on nyt uudelleenkäytettävä nappi, sovellukselle on lisätty uutena toiminnallisuutena nappi, jolla laskurin arvoa voi vähentää.</p>
<p>Tapahtumankäsittelijä välitetään napeille propsin <em>handleClick</em> välityksellä. Propsin nimellä ei ole sinänsä merkitystä, mutta valinta ei ollut täysin sattumanvarainen, esim. Reactin <a href="https://reactjs.org/tutorial/tutorial.html">tutoriaali</a> suosittelee tätä konventiota.</p>
<h3>Monimutkaisemman tilan päivittäminen</h3>
<p>Tarkastellaan sovellusta, jonka tila on hieman monimutkaisempi:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      vasen: 0,
      oikea: 0
    }
  }

  klikVasen = () =&gt; {
    this.setState({
      vasen: this.state.vasen + 1
    })
  }

  klikOikea = () =&gt; {
    this.setState({
      oikea: this.state.oikea + 1
    })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          {this.state.vasen}
          &lt;button onClick={this.klikVasen}&gt;vasen&lt;/button&gt;
          &lt;button onClick={this.klikOikea}&gt;oikea&lt;/button&gt;
          {this.state.oikea}
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Tilassa on siis kaksi kenttää, <em>vasen</em> ja <em>oikea</em> jotka laskevat vastaavien nappien painalluksia.</p>
<p>Kun tilaa päivitetään, riittää asettaa ainoastaan muuttuvan kentän arvo, sillä React <a href="https://reactjs.org/docs/state-and-lifecycle.html#state-updates-are-merged">lomittaa</a> tai &quot;mergeää&quot; muutokset olemassaolevaan tilaan.</p>
<p>Eli kun päivitämme esim. vasemman napin painalluksia, riittää seuraava koodi</p>
<pre><code class="language-js">klikVasen = () =&gt; {
  this.setState({
    vasen: this.state.vasen + 1,
  });
};
</code></pre>
<p>tilassa oleva kenttä <em>oikea</em> jää muutoksen yhteydessä ennalleen.</p>
<h3>Taulukon käsittelyä</h3>
<p>Tehdään sovellukseen vielä laajennus, lisätään tilaan taulukko <em>kaikki</em> joka muistaa kaikki näppäimenpainallukset.</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      vasen: 0,
      oikea: 0,
      kaikki: []
    }
  }

  klikVasen = () =&gt; {
    this.setState({
      vasen: this.state.vasen + 1,
      kaikki: this.state.kaikki.concat(&#x27;v&#x27;)
    })
  }

  klikOikea = () =&gt; {
    this.setState({
      oikea: this.state.oikea + 1,
      kaikki: this.state.kaikki.concat(&#x27;o&#x27;)
    })
  }

  render() {
    const historia = () =&gt; this.state.kaikki.join(&#x27; &#x27;)
    return (
      &lt;div&gt;
        &lt;div&gt;
          {this.state.vasen}
          &lt;button onClick={this.klikVasen}&gt;vasen&lt;/button&gt;
          &lt;button onClick={this.klikOikea}&gt;oikea&lt;/button&gt;
          {this.state.oikea}
          &lt;div&gt;{historia()}&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Kun esim. nappia <em>vasen</em> painetaan, lisätään tilan taulukkoon <em>kaikki</em> kirjain <em>v</em>:</p>
<pre><code class="language-js">klikVasen = () =&gt; {
  this.setState({
    vasen: this.state.vasen + 1,
    kaikki: this.state.kaikki.concat(&#x27;v&#x27;),
  });
};
</code></pre>
<p>Tilan kenttä <em>kaikki</em> saa nyt arvokseen entisen tilan, mihin on liitetty <em>v</em> metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">concat</a>, joka toimii siten, että se ei muuta olemassaolevaa taulukkoa vaan luo <em>uuden taulukon</em>, mihin uusi alkio on lisätty.</p>
<p>Javascriptissa on myös mahdollista lisätä taulukkoon metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push">push</a> ja sovellus näyttäisi tässä tilanteessa toimivan myös jos lisäys tapahtuisi komennolla</p>
<pre><code class="language-js">kaikki: this.state.kaikki.push(&#x27;v&#x27;);
</code></pre>
<p>mutta älä tee niin. React-komponentin tilaa, eli muuttujaa <em>this.state</em> ei saa muuttaa suoraan!</p>
<p><strong>Jos tilan kentissä on olioita, älä muuta niitä vaan tee muutos aina kopioon!</strong></p>
<p>Katsotaan vielä tarkemmin, miten kaikkien painallusten historia renderöidään ruudulle:</p>
<pre><code class="language-react">render() {
  const historia = () =&gt; this.state.kaikki.join(&#x27; &#x27;)
  return (
    &lt;div&gt;
      &lt;div&gt;
        {this.state.vasen}
        &lt;button onClick={this.klikVasen}&gt;vasen&lt;/button&gt;
        &lt;button onClick={this.klikOikea}&gt;oikea&lt;/button&gt;
        {this.state.oikea}
        &lt;div&gt;{historia()}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Metodiin <em>render</em> on nyt määritelty apufunktio:</p>
<pre><code class="language-react">const historia = () =&gt; this.state.kaikki.join(&#x27; &#x27;)
</code></pre>
<p>Taulukon <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join">join</a>-metodilla muodostetaan taulukosta merkkijono, joka sisältää taulukon alkiot erotettuina välilyönnillä.</p>
<h3>Ehdollinen renderöinti</h3>
<p>Muutetaan apufunktiota hiukan:</p>
<pre><code class="language-react">const historia = () =&gt; {
  if (this.state.kaikki.length === 0) {
    return (
      &lt;div&gt;
        &lt;em&gt;sovellusta käytetään nappeja painelemalla&lt;/em&gt;
      &lt;/div&gt;
    )
  }
  return (
    &lt;div&gt;
      näppäilyhistoria: {this.state.kaikki.join(&#x27; &#x27;)}
    &lt;/div&gt;
  )
}
</code></pre>
<p>Nyt funktion palauttama sisältö riippuu siitä, onko näppäimiä jo painettu. Jos ei, eli taulukko <code>this.state.kaikki</code> on tyhjä, palauttaa metodi &quot;käyttöohjeen&quot; sisältävän elementin</p>
<pre><code class="language-html">&lt;div&gt;&lt;em&gt;sovellusta käytetään nappeja painelemalla&lt;/em&gt;&lt;/div&gt;
</code></pre>
<p>ja muussa tapauksessa näppäilyhistorian:</p>
<pre><code class="language-html">&lt;div&gt;näppäilyhistoria: {this.state.kaikki.join(&#x27; &#x27;)}&lt;/div&gt;
</code></pre>
<p>Komponentin <em>App</em> ulkoasun muodostamat React-elementit siis ovat erilaisia riippuen sovelluksen tilasta, eli komponentissa on <em>ehdollista renderöintiä</em>.</p>
<p>Reactissa on monia muitakin tapoja <a href="https://reactjs.org/docs/conditional-rendering.html">ehdolliseen renderöintiin</a>. Katsotaan niitä tarkemmin <a href="/osa2">seuraavassa osassa</a>.</p>
<p>Näppäilyhistorian esittäminen alkaa olla jo sen verran monimutkainen operaatio, että se kannattaisi eristää omaksi komponentikseen. Jätämme sen kuitenkin tekemättä.</p>
<h2>Funktionaalinen vai luokkasyntaksiin perustuva komponentti?</h2>
<p>Olemme nyt esitelleet kaksi erilaista tapaa komponenttien määrittelemiseen. Kumpaa tulisi käyttää? Useimpien vastauksena on, <a href="https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc">käytä funktionaalista komponenttia aina kun se on mahdollista</a>.</p>
<p>Jos komponentti tarvitsee tilaa, on luokkasyntaksin käyttäminen välttämätöntä. Kannattaa kuitenkin muistaa, että Reactin filosofian mukaista on sijoittaa tila <a href="https://reactjs.org/docs/lifting-state-up.html">mahdollisimman ylös</a> komponenttihierarkiaan, mielellään ainoastaan sovelluksen juurikomponenttiin. Näin tilallisten komponenttien potentiaalinen tarvekin on vähäisempi.</p>
<p>Joskus komponenttien on käytettävä <a href="/osa2#komponenttien-lifecycle-metodit">osassa 2 esiteltäviä</a> lifecycle-metodeja, myös niissä tapauksissa on pakko käyttää luokkiin perustuvia komponentteja.</p>
<p>Yleisohjeena on siis se, että käytä funktionaalisia komponentteja ellet aivan pakosti tarvitse jotain luokkasyntaksin omaavien komponenttien ominaisuuksia.</p>
<p>Internetistä löytyy kyllä aiheesta päinvastaisiakin mielipiteitä, esim. <a href="https://medium.freecodecamp.org/7-reasons-to-outlaw-reacts-functional-components-ff5b5ae09b7c">7 Reasons to Outlaw React’s Functional Components</a></p>
<h2>React-sovellusten debuggaus</h2>
<p>Ohjelmistokehittäjän elämä koostuu pääosin debuggaamisesta (ja olemassaolevan koodin lukemisesta). Silloin tällöin syntyy toki muutama rivi uuttakin koodia, mutta suuri osa ajasta ihmetellään miksi joku on rikki tai miksi joku asia ylipäätään toimii. Hyvät debuggauskäytänteet ja työkalut ovatkin todella tärkeitä.</p>
<p>Onneksi React on debuggauksen suhteen jopa harvinaisen kehittäjäystävällinen kirjasto.</p>
<p>Muistutetaan vielä tärkeimmästä web-sovelluskehitykseen liittyvästä asiasta:</p>
<div class="important">
  <h3>Web-sovelluskehityksen sääntö numero yksi</h3>
  <div>Pidä selaimen developer-konsoli koko ajan auki.</div>
  <br/>
  <div>Välilehdistä tulee olla auki nimenomaan <em>Console</em> jollei ole erityistä syytä käyttää jotain muuta välilehteä.
  </div>
</div>
<p>Pidä myös koodi ja web-sivu <strong>koko ajan</strong> molemmat yhtä aikaa näkyvillä.</p>
<p>Jos ja kun koodi ei käänny, eli selaimessa alkaa näkyä punaista</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/18270e38776d63a180eaa5d0e835c47b/14be6/31.png"/></picture>
<p>älä kirjota enää lisää koodia vaan selvitä ongelma <strong>välittömästi</strong>. Koodauksen historia ei tunne tilannetta, missä kääntymätön koodi alkaisi ihmeenomaisesti toimimaan kirjoittamalla suurta määrää lisää koodia, en usko että sellaista ihmettä nähdään tälläkään kurssilla.</p>
<p>Vanha kunnon printtaukseen perustuva debuggaus kannattaa aina. Eli jos esim. komponentissa</p>
<pre><code class="language-react">const Button = ({ handleClick, text }) =&gt; (
  &lt;button onClick={handleClick}&gt;
    {text}
  &lt;/button&gt;
)
</code></pre>
<p>olisi jotain ongelmia, kannattaa komponentista alkaa printtailla konsoliin. Pystyäksemme printtaamaan, tulee funktio muuttaa pitempään muotoon ja propsit kannattaa kenties vastaanottaa ilman destrukturointia:</p>
<pre><code class="language-react">const Button = (props) =&gt; {
  console.log(props)
  const { handleClick, text } = props
  return (
    &lt;button onClick={handleClick}&gt;
      {text}
    &lt;/button&gt;
  )
}
</code></pre>
<p>näin selviää heti onko esim. joku propsia vastaava attribuutti nimetty väärin komponenttia käytettäessä.</p>
<p><strong>HUOM</strong> kun käytät komentoa <em>console.log</em> debuggaukseen, älä yhdistele asioita &quot;javamaisesti&quot; plussalla, eli sen sijaan että kirjoittaisit</p>
<pre><code class="language-js">console.log(&#x27;propsin arvo on&#x27; + props);
</code></pre>
<p>erottele tulostettavat asiat pilkulla:</p>
<pre><code class="language-js">console.log(&#x27;propsin arvo on&#x27;, props);
</code></pre>
<p>Jos yhdistät merkkijonoon olion, tuloksena on suhteellisen hyödytön tulostusmuoto</p>
<pre><code class="language-bash">propsin arvo on [Object object]
</code></pre>
<p>kun taas pilkulla tulostettavat asiat erotellessa saat developer-konsoliin olion, jonka sisältöä on mahdollista tarkastella.</p>
<p>Koodin suorituksen voi pysäyttää chromen developer konsolin debuggeriin kirjoittamalla mihin tahansa kohtaa koodia komennon <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">debugger</a>.</p>
<p>Koodi pysähtyy kun suoritus etenee sellaiseen pisteeseen, että komento <em>debugger</em> suoritetaan:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/167e2809b58a918d3712bc3f3bde44f4/14be6/32.png"/></picture>
<p>Menemällä välilehdelle <em>Console</em> on helppo tutkia muuttujien tilaa:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/818bfabf9c172ac61a6a1ed04cfa839f/14be6/33.png"/></picture>
<p>Kun bugi selviää, voi komennon <em>debugger</em> poistaa ja uudelleenladata sivun.</p>
<p>Debuggerissa on mahdollista suorittaa koodia tarvittaessa rivi riviltä <em>Source</em> välilehden oikealta laidalta.</p>
<p>Debuggeriin pääsee myös ilman komentoa <em>debugger</em> lisäämällä <em>Source</em>-välilehdellä sopiviin kohtiin koodia <em>breakpointeja</em>. Haluttujen muuttujien arvojen tarkkailu on mahdollista määrittelemällä ne <em>Watch</em>-osassa:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/4f7c09049d9ada807b3d2864c7b01bae/14be6/34.png"/></picture>
<p>Chromeen kannattaa ehdottomasti asentaa <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React developer tools</a> -lisäosa, joka tuo konsoliin uuden tabin <em>React</em>:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/71448901a59a141227a6b67f7a53ffa2/14be6/35.png"/></picture>
<p>Uuden konsolitabin avulla voidaan tarkkailla sovelluksen React-elementtejä ja niiden tilaa (eli this.state:a) ja propseja.</p>
<h2>Tapahtumankäsittely revisited</h2>
<p>Pajan ja telegrammin havaintojen perusteella tapahtumankäsittely on osoittautunut haastavaksi.</p>
<p>Tarkastellaan asiaa vielä uudelleen.</p>
<p>Oletetaan, että käytössä on äärimmäisen yksinkertainen sovellus:</p>
<pre><code class="language-bash">class App extends React.Component {
  constructor() {
    super()
    this.state = {
      value: 10
    }
  }
  render(){
    return (
      &lt;div&gt;
        {this.state.value}
        &lt;button&gt;nollaa&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Haluamme, että napin avulla tilassa oleva <em>value</em> saadaan nollattua.</p>
<p>Jotta saamme napin reagoimaan, on sille lisättävä <em>tapahtumankäsittelijä</em>.</p>
<p>Tapahtumankäsittelijän tulee aina olla <em>funktio</em>. Jos tapahtumankäisttelijän paikalle yritetään laittaa jotain muuta, ei nappi toimi.</p>
<p>Jos esim. antaisimme tapahtumankäsittelijäksi merkkijonon:</p>
<pre><code class="language-bash">&lt;button onClick={&quot;roskaa&quot;}&gt;nappi&lt;/button&gt;
</code></pre>
<p>React varoittaa asiasta konsolissa</p>
<pre><code class="language-bash">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `string` type.
    in button (at index.js:20)
    in div (at index.js:18)
    in App (at index.js:27)
</code></pre>
<p>eli esim. seuraavanlainen yritys olisi tuhoon tuomittu</p>
<pre><code class="language-bash">&lt;button onClick={this.state.value+1}&gt;nappi&lt;/button&gt;
</code></pre>
<p>nyt tapahtumankäsittelijäksi on yritetty laittaa <em>this.state.value+1</em> mikä tarkoittaa laskuoperaation tulosta. React varoittaa tästäkin konsolissa</p>
<pre><code class="language-bash">index.js:2178 Warning: Expected `onClick` listener to be a function, instead got a value of `number` type.
</code></pre>
<p>Myöskään seuraava ei toimi</p>
<pre><code class="language-bash">&lt;button onClick={this.state.value = 0}&gt;nappi&lt;/button&gt;
</code></pre>
<p>taaskaan tapahtumankäsittelijänä ei ole funktio vaan sijoitusoperaatio. Konsoliin tulee valitus. Tämä tapa on myös toisella tavalla väärin. Kuten on jo mainittu, reactin tilaa <em>ei saa muuttaa suoraan</em>, vaan ainoastaan funktion setState-avulla.</p>
<p>Entä seuraava:</p>
<pre><code class="language-bash">&lt;button onClick={console.log(&#x27;nappia painettu&#x27;)}&gt;nappi&lt;/button&gt;
</code></pre>
<p>konsoliin tulostuu kertaalleen <em>nappia painettu</em>, mutta nappia painellessa ei tapahdu mitään. Miksi tämä ei toimi vaikka tapahtumankäsittelijänä on nyt funktio <em>console.log</em>?</p>
<p>Ongelma on nyt siinä, että tapahtumankäsittelijänä on funktion kutsu, eli varsinaiseksi tapahtumankäsittelijäksi tulee funktion kutsun paluuarvo, joka on tässä tapauksessa <em>undefined</em>.</p>
<p>Funktiokutsu <em>console.log(&#x27;nappia painettu&#x27;)</em> suoritetaan siinä vaiheessa kun komponentti renderöidään, ja tämän takia konsoliin tulee tulostus kertalleen.</p>
<p>Myös seuraava yritys on virheellinen</p>
<pre><code class="language-bash">&lt;button onClick={this.setState({value: 0})}&gt;nappi&lt;/button&gt;
</code></pre>
<p>jälleen olemme yrittäneet laittaa tapahtumankäsittelijäksi funktiokutsun. Ei toimi. Tämä yritys aiheuttaa myös toisen ongelman. Kun komponenttia renderöidään, suoritetaan tapahtumankäsittelijänä oleva funktiokutsu <em>this.setState({value: 0})</em> joka taas saa aikaan komponentin uudelleenrenderöinnin. Ja uudelleenrenderöinnin yhteydessä funktiota kutsutaan uudelleen käynnistäen jälleen uusi uudelleenrenderöinti, ja joudutaan päättymättömään rekursioon.</p>
<p>Jos haluamme tietyn funktiokutsun tapahtuvan nappia painettaessa, toimii seuraava</p>
<pre><code class="language-bash">&lt;button onClick={() =&gt; console.log(&#x27;nappia painettu&#x27;)}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Nyt tapahtumankäsittelijä on nuolisyntaksilla määritelty funktio <em>() =&gt; console.log(&#x27;nappia painettu&#x27;)</em>. Kun komponentti renderöidään, ei suoriteta mitään, ainoastaan talletetaan funktioviite tapahtumankäsittelijäksi. Itse funktion suoritus tapahtuu vasta napin painallusten yhteydessä.</p>
<p>Saamme myös nollauksen toimimaan samalla tekniikalla</p>
<pre><code class="language-bash">&lt;button onClick={() =&gt; this.setState({value: 0})}&gt;nappi&lt;/button&gt;
</code></pre>
<p>eli nyt tapahtumankäsittelijä on funktio <em>() =&gt; this.setState({value: 0})</em>.</p>
<p>Tapahtumakäsittelijäfunktioiden määrittely suoraan napin määrittelyn yhteydessä ei välttämättä ole paras mahdollinen idea.</p>
<p>Usein tapahtumankäsittelijä määritelläänkin jossain muualla. Seuraavassa määritellään funktio metodin render alussa ja sijoitetaan se muuttujaan <em>handler</em>:</p>
<pre><code class="language-react">render() {
  const handler = () =&gt; console.log(&#x27;nappia painettu&#x27;)

  return (
    &lt;div&gt;
      {this.state.value}
      &lt;button onClick={handler}&gt;nappi&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Muuttujassa <em>handler</em> on nyt talletettuna viite itse funktioon. Viite annetaan napin määrittelyn yhteydessä</p>
<pre><code class="language-bash">&lt;button onClick={handler}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Tapahtumankäsittelijäfunktio voi luonnollisesti koostua useista komennoista, tällöin käytetään nuolifunktion aaltosulullista muotoa:</p>
<pre><code class="language-react">render() {
  const handler = () =&gt; {
    console.log(&#x27;nappia painettu&#x27;)
    this.setState({ value: 0 })
  }

  return (
    &lt;div&gt;
      {this.state.value}
      &lt;button onClick={handler}&gt;nappi&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Joissain tilanteissa tapahtumankäsittelijät kannattaa määritellä komponentin metodeina:</p>
<pre><code class="language-react">class App extends React.Component {
  // ...

  handler = () =&gt; {
    console.log(&#x27;nappia painettu&#x27;)
    this.setState({ value: 0 })
  }

  render() {
    return (
      &lt;div&gt;
        {this.state.value}
        &lt;button onClick={this.handler}&gt;nappi&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Koska <em>handler</em> on nyt komponentin metodi, päästään siihen käsiksi viitteen <em>this</em> avulla:</p>
<pre><code class="language-bash">&lt;button onClick={this.handler}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Mennään lopuksi funktioita palauttavaan funktioon.</p>
<p>Muutetaan koodia seuraavasti</p>
<pre><code class="language-react">render() {
  const hello = () =&gt; {
    const handler = () =&gt; console.log(&#x27;hello world&#x27;)

    return handler
  }

  return (
    &lt;div&gt;
      {this.state.value}
      &lt;button onClick={hello()}&gt;nappi&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Koodi näyttää hankalalta mutta se ihme kyllä toimii.</p>
<p>Tapahtumankäsittelijäksi on nyt &quot;rekisteröity&quot; funktiokutsu:</p>
<pre><code class="language-bash">&lt;button onClick={hello()}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Aiemmin varoteltiin, että tapahtumankäsittelijä ei saa olla funktiokutsu vaan sen on oltava funktio tai viite funktioon. Miksi funktiokutsu kuitenkin toimii nyt?</p>
<p>Kun komponenttia renderöidään suoritetaan seuraava funktio:</p>
<pre><code class="language-react">const hello = () =&gt; {
  const handler = () =&gt; console.log(&#x27;hello world&#x27;)

  return handler
}
</code></pre>
<p>funktion <em>paluuarvona</em> on nyt toinen, muuttujaan <em>handler</em> määritelty funktio.</p>
<p>eli kun react renderöi seuraavan rivin</p>
<pre><code class="language-bash">&lt;button onClick={hello()}&gt;nappi&lt;/button&gt;
</code></pre>
<p>sijoittaa se onClick-käsittelijäksi funktiokutsun <em>hello()</em> paluuarvon. Eli oleellisesti ottaen rivi &quot;muuttuu&quot; seuraavaksi</p>
<pre><code class="language-bash">&lt;button onClick={() =&gt; console.log(&#x27;hello world&#x27;)}&gt;nappi&lt;/button&gt;
</code></pre>
<p>koska funktio <em>hello</em> palautti funktion, on tapahtumankäsittelijä nyt funktio.</p>
<p>Mitä järkeä tässä konseptissa on?</p>
<p>Muutetaan koodia hiukan:</p>
<pre><code class="language-bash">render() {
  const hello = (who) =&gt; {
    const handler = () =&gt; { 
      console.log(&#x27;hello&#x27;, who)
    }

    return handler
  }

  return (
    &lt;div&gt;
      {this.state.value}
      &lt;button onClick={hello(&#x27;world&#x27;)}&gt;nappi&lt;/button&gt;
      &lt;button onClick={hello(&#x27;react&#x27;)}&gt;nappi&lt;/button&gt;
      &lt;button onClick={hello(&#x27;function&#x27;)}&gt;nappi&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Nyt meillä on kolme nappia joiden tapahtumankäsittelijät määritellään parametrin saavan funktion <em>hello</em> avulla.</p>
<p>Ensimmäinen nappi määritellään seuraavasti</p>
<pre><code class="language-bash">&lt;button onClick={hello(&#x27;world&#x27;)}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Tapahtumankäsittelijä siis saadaan <em>suorittamalla</em> funktiokutsu <em>hello(&#x27;world&#x27;)</em>. Funktiokutsu palauttaa funktion</p>
<pre><code class="language-bash">() =&gt; { 
  console.log(&#x27;hello&#x27;, &#x27;world&#x27;)
}
</code></pre>
<p>Toinen nappi määritellään seuraavasti</p>
<pre><code class="language-bash">&lt;button onClick={hello(&#x27;react&#x27;)}&gt;nappi&lt;/button&gt;
</code></pre>
<p>Tapahtumankäsittelijän määrittelevä funktiokutsu <em>hello(&#x27;react&#x27;)</em> palauttaa</p>
<pre><code class="language-bash">() =&gt; { 
  console.log(&#x27;hello&#x27;, &#x27;react&#x27;)
}
</code></pre>
<p>eli nappi saa oman yksilöllisen tapahtumankäsittelijänsä.</p>
<p>Funktioita palauttavia funktioita voikin hyödyntää määrittelemään geneeristä toiminnallisuutta, jota voi tarkentaa parametrien avulla. Tapahtumankäsittelijöitä luovan funktion <em>hello</em> voikin ajatella olevan eräänlainen tehdas, jota voi pyytää valmistamaan sopivia tervehtimiseen tarkoitettuja tapahtumankäsittelijäfunktioita.</p>
<p>Käyttämämme määrittelytapa</p>
<pre><code class="language-bash">const hello = (who) =&gt; {
  const handler = () =&gt; { 
    console.log(&#x27;hello&#x27;, who)
  }

  return handler
}
</code></pre>
<p>on hieman verboosi. Eliminoidaan apumuuttuja, ja määritellään palautettava funktio suoraan returnin yhteydessä:</p>
<pre><code class="language-bash">const hello = (who) =&gt; {
  return () =&gt; { 
    console.log(&#x27;hello&#x27;, who)
  }
}
</code></pre>
<p>ja koska funktio <em>hello</em> sisältää ainoastaan yhden komennon, eli returnin, voidaan käyttää aaltosulutonta muotoa</p>
<pre><code class="language-bash">const hello = (who) =&gt;
  () =&gt; { 
    console.log(&#x27;hello&#x27;, who)
  }
</code></pre>
<p>ja tuodaan vielä &quot;kaikki nuolet&quot; samalle riville</p>
<pre><code class="language-bash">const hello = (who) =&gt; () =&gt; { 
  console.log(&#x27;hello&#x27;, who)
}
</code></pre>
<p>Voimme käyttää samaa kikkaa myös muodostamaan tapahtumankäsittelijöitä, jotka asettavat komponentin tilalle halutun arvon. Muutetaan koodi muotoon:</p>
<pre><code class="language-bash">render() {
  const setToValue = (newValue) =&gt; () =&gt; { 
    this.setState({ value: newValue })
  }

  return (
    &lt;div&gt;
      {this.state.value}
      &lt;button onClick={setToValue(1000)}&gt;tuhat&lt;/button&gt;
      &lt;button onClick={setToValue(0)}&gt;nollaa&lt;/button&gt;
      &lt;button onClick={setToValue(this.state.value+1)}&gt;kasvata&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Kun komponentti renderöidään, ja tehdään nappia tuhat</p>
<pre><code class="language-bash">&lt;button onClick={setToValue(1000)}&gt;tuhat&lt;/button&gt;
</code></pre>
<p>tulee tapahtumankäsittelijäksi funktiokutsun <em>setToValue(1000)</em> paluuarvo eli seuraava funktio</p>
<pre><code class="language-bash">() =&gt; { 
  this.setState({ value: 1000 })
}
</code></pre>
<p>Kasvatusnapin generoima rivi on seuraava</p>
<pre><code class="language-bash">&lt;button onClick={setToValue(this.state.value+1)}&gt;kasvata&lt;/button&gt;
</code></pre>
<p>Tapahtumankäsittelijän muodostaa funktiokutsu <em>setToValue(this.state.value+1)</em>, joka saa parametrikseen tilan kentän <em>value</em> nykyisen arvon kasvatettuna yhdellä. Jos <em>this.state.value</em> olisi 10, tulisi tapahtumankäsittelijäksi funktio</p>
<pre><code class="language-bash">() =&gt; { 
  this.setState({ value: 11 })
}
</code></pre>
<h3>Hyödyllistä materiaalia</h3>
<p>Internetissä on todella paljon Reactiin liittyvää materiaalia, tässä muutamia linkkejä:</p>
<ul>
<li>Reactin <a href="https://reactjs.org/docs/hello-world.html">docs</a> kannattaa ehdottomasti käydä läpi, ei välttämättä kaikkea nyt, osa on ajankohtaista vasta kurssin myöhemmissä osissa</li>
<li>Reactin sivuilla oleva <a href="https://reactjs.org/tutorial/tutorial.html">tutoriaali</a> sen sijaan on aika huono</li>
<li><a href="https://egghead.io">Egghead.io</a>:n kursseista <a href="https://egghead.io/courses/start-learning-react">Start learning React</a> on laadukas, ja hieman uudempi <a href="https://egghead.io/courses/the-beginner-s-guide-to-reactjs">The Beginner&#x27;s guide to React</a> on myös kohtuullisen hyvä; molemmat sisältävät myös asioita jotka tulevat tällä kurssilla vasta myöhemmissä osissa.</li>
</ul>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#AEFFDA"><div class="container"><div class="course-content col-7 push-right-3">
  <h3>Tehtävät 1.6</h3>
  <h4>unicafe osa1</h4>
<p>Monien firmojen tapaan nykyään myös <a href="https://www.unicafe.fi/#/9/4">Unicafe</a> kerää asiakaspalautetta. Tee Unicafelle verkossa toimiva palautesovellus. Vastausvaihtoehtoja olkoon vain kolme: <i>hyvä</i>, <i>neutraali</i> ja <i>huono</i>.</p>
<p>Sovelluksen tulee näyttää jokaisen palautteen lukumäärä. Sovellus voi näyttää esim. seuraavalta:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/41cc3de89532b4d79fa7700e66e333fb/14be6/4c.png"/></picture>
<p>Huomaa, että sovelluksen tarvitsee toimia vain yhden selaimen käyttökerran ajan, esim. kun selain refreshataan, tilastot saavat hävitä.</p>
<h3>Tehtävät 1.7</h3>
<h4>unicafe osa2</h4>
<p>Laajenna sovellusta siten, että se näyttää palautteista statistiikkaa, keskiarvon (hyvän arvo 1, neutraalin 0, huonon -1) ja sen kuinka monta prosenttia palautteista on ollut positiivisia:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/8eeaee33949da20b66c30a6737f127aa/14be6/4d.png"/></picture>
<h3>Tehtävät 1.8</h3>
<h4>unicafe osa3</h4>
<p>Refaktoroi sovelluksesi siten, että se koostuu monista komponenteista. Pidä tila kuitenkin sovelluksen <em>juurikomponentissa</em>.</p>
<p>Tee sovellukseen ainakin seuraavat komponentit:</p>
<ul>
<li><i>Button</i> vastaa yksittäistä palautteenantonappia</li>
<li><i>Statistics</i> huolehtii tilastojen näyttämisestä</li>
<li><i>Statistic</i> huolehtii yksittäisen tilastorivin, esim. keskiarvon näyttämisestä</li>
</ul>
<h3>Tehtävät 1.9</h3>
<h4>unicafe osa4</h4>
<p>Muuta sovellusta siten, että numeeriset tilastot näytetään ainoastaan jos palautteita on jo annettu:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/ca65701774021dc5840250dfdb6778d2/14be6/5.png"/></picture>
<h3>Tehtävät 1.10*</h3>
<h4>unicafe osa5</h4>
<p>Jos olet määritellyt jokaiselle napille oman tapahtumankäsittelijän, refaktoroi sovellustasi siten, että kaikki napit käyttävät samaa tapahtumankäsittelijäfunktiota samaan tapaan kuin materiaalin luvussa <a href="/osa1/#funktio-joka-palauttaa-funktion">funktio joka palauttaa funktion</a>.</p>
<p>Pari vihjettä. Ensinnäkin kannattaa muistaa, että olion kenttiin voi viitata pistenotaation lisäksi hakasulkeilla, eli:</p>
<pre><code class="language-js">const olio = {
  a: 1,
  b: 2,
};

olio[&#x27;c&#x27;] = 3;

console.log(olio.a); // tulostuu 1

console.log(olio[&#x27;b&#x27;]); // tulostuu 2

const apu = &#x27;c&#x27;;
console.log(olio[apu]); // tulostuu 3
</code></pre>
<p>Myös ns. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">Computed property names</a> voi olla tässä tehtävässä hyödyksi.</p>
<h3>Tehtävät 1.11</h3>
<h4>unicafe osa6</h4>
<p>Toteuta tilastojen näyttäminen HTML:n <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics">taulukkona</a> siten, että saat sovelluksesi näyttämään suunnilleen seuraavanlaiselta:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/7500dfe6da204285cc1702be1538b140/14be6/6a.png"/></picture>
<p>Muista pitää konsoli koko ajan auki. Jos saat konsoliin seuraavan warningin:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/cd8396f95df840c13fee0f449f049a06/14be6/7.png"/></picture>
<p>tee tarvittavat toimenpiteet jotta saat warningin katoamaan. Googlaa tarvittaessa virheilmoituksella.</p>
<p><strong>Huolehdi nyt ja jatkossa, että konsolissa ei näy mitään warningeja!</strong></p>
<h3>Tehtävät 1.12*</h3>
<h4>anekdootit osa1</h4>
<p>Ohjelmistotuotannossa tunnetaan lukematon määrä <a href="http://www.comp.nus.edu.sg/~damithch/pages/SE-quotes.htm">anekdootteja</a> eli pieniä &quot;onelinereita&quot;, jotka kiteyttävät alan ikuisia totuuksia.</p>
<p>Laajenna seuraavaa sovellusta siten, että siihen tulee nappi, jota painamalla sovellus näyttää <em>satunnaisen</em> ohjelmistotuotantoon liittyvän anekdootin:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import ReactDOM from &#x27;react-dom&#x27;

class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      selected: 0
    }
  }

  render() {
    return (
      &lt;div&gt;
        {this.props.anecdotes[this.state.selected]}
      &lt;/div&gt;
    )
  }
}

const anecdotes = [
  &#x27;If it hurts, do it more often&#x27;,
  &#x27;Adding manpower to a late software project makes it later!&#x27;,
  &#x27;The first 90 percent of the code accounts for the first 90 percent of the development time...The remaining 10 percent of the code accounts for the other 90 percent of the development time.&#x27;,
  &#x27;Any fool can write code that a computer can understand. Good programmers write code that humans can understand.&#x27;,
  &#x27;Premature optimization is the root of all evil.&#x27;,
  &#x27;Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.&#x27;
]

ReactDOM.render(
  &lt;App anecdotes={anecdotes} /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Google kertoo, miten voit generoida Javascriptilla sopivia satunnaisia lukuja. Muista, että voit testata esim. satunnaislukujen generointia konsolissa.</p>
<p>Sovellus voi näyttää esim. seuraavalta:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/a58354ed43c6ee83bab346b1ed5240a7/14be6/2.png"/></picture>
<h3>Tehtävät 1.13*</h3>
<h4>anekdootit osa2</h4>
<p>Laajenna sovellusta siten, että näytettävää anekdoottia on mahdollista äänestää:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/fbb8bc0bc2a60aa9b725f45b2c2911d1/14be6/3.png"/></picture>
<p><strong>Huom:</strong> jos päätät tallettaa kunkin anekdootin äänet komponentin tilassa olevan olion kenttiin tai taulukkoon, saatat tarvita päivittäessäsi tilaa oikeaoppisesti olion tai taulukon <em>kopioimista</em>.</p>
<p>Olio voidaan kopioida esim. seuraavasti:</p>
<pre><code class="language-js">const pisteet = { 0: 1, 1: 3, 2: 4, 3: 2 };

const kopio = { ...pisteet };
kopio[2] += 1; // kasvatetaan olion kentän 2 arvoa yhdellä
</code></pre>
<p>ja taulukko esim. seuraavasti:</p>
<pre><code class="language-js">const pisteet = [1, 4, 6, 3];

const kopio = [...pisteet];
kopio[2] += 1; // kasvatetaan taulukon paikan 2 arvoa yhdellä
</code></pre>
<h3>Tehtävät 1.14*</h3>
<h4>anekdootit osa3</h4>
<p>Ja sitten vielä lopullinen versio, joka näyttää eniten ääniä saaneen anekdootin:</p>
<picture><img style="border-color:#AEFFDA" alt="asd" src="/static/2b1a015cd08c9b5ef3eb334813978d99/14be6/3b.png"/></picture>
<p>Jos suurimman äänimäärän saaneita anekdootteja on useita, riittää että niistä näytetään yksi.</p>
<p>Tämä saattaa olla jo hieman haastavampi. Taulukolta löytyy monia hyviä metodeja, katso lisää <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Mozillan dokumentaatiosta</a>.</p>
<p>Youtubessa on kohtuullisen hyvä <a href="https://www.youtube.com/watch?v=BMUiFMZr7vk&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84">johdatus funktionaaliseen javascript-ohjelmointiin</a>. Kolmen ensimmäisen osan katsominen riittää hyvin tässä vaiheessa.</p>
</div></div></div></div><div class="container spacing element--flex element--column element--centered"><div class="body-text "><p class="body-text__content bold">Tehtävien palautus</p></div><a href="https://studies.cs.helsinki.fi/fullstackopen/" style="padding:1rem 0" class="col-2 centered spacing--small"><div class="triple-border  triple-border--large-margin" style="padding:"><div class="triple-border__container triple-border__return-tasks" style="background-color:transparent">Palauta tehtävät palautussovellukseen</div></div></a></div><div class="container spacing spacing--after-large "><a class="push-right-1" href="/osa0"><div class=" element--flex element--column"><p style="text-align:right">Osa <!-- -->0</p><b>Edellinen osa</b></div></a><a class="push-left-1" href="/osa2"><div class=" element--flex element--column"><p>Osa <!-- -->2</p><b>Seuraava osa</b></div></a></div></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-content-template-js","jsonName":"osa-1-javascript-59c","path":"/osa1/javascript"};window.dataPath="882/path---osa-1-javascript-59-c-88f-GYjSanASlU3pt2Yq2xYEOCbv8jw";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-ea23b7086a93b0204497.js"],"component---src-templates-content-template-js":["/component---src-templates-content-template-js.bb6688043828bda42216.css","/component---src-templates-content-template-js-1511b04e7342894ff772.js"],"component---src-pages-404-js":["/component---src-pages-404-js-d105615186347619f3ea.js"],"component---src-pages-about-js":["/component---src-pages-about-js.9cb33badb6596f6554cf.css","/component---src-pages-about-js-48044514fc0697baaeec.js"],"component---src-pages-companies-js":["/component---src-pages-companies-js-8ccc1ef3cfee87833041.js"],"component---src-pages-faq-js":["/component---src-pages-faq-js-ac90fd3ee9c727a46e04.js"],"component---src-pages-index-js":["/component---src-pages-index-js.054d4c52cecca6da6c62.css","/component---src-pages-index-js-f578c0bbea6458e6b338.js"],"component---src-pages-osa-0-js":["/component---src-pages-osa-0-js.b8658faab52da8be69f9.css","/component---src-pages-osa-0-js-0b568ab179fefcc2b753.js"],"component---src-pages-osa-1-js":["/component---src-pages-osa-1-js.b8658faab52da8be69f9.css","/component---src-pages-osa-1-js-dd90edd515f7032c8e0d.js"],"component---src-pages-osa-2-js":["/component---src-pages-osa-2-js.b8658faab52da8be69f9.css","/component---src-pages-osa-2-js-839c7c09aa8e4a4c13d9.js"],"component---src-pages-osa-3-js":["/component---src-pages-osa-3-js.b8658faab52da8be69f9.css","/component---src-pages-osa-3-js-31955868da18833a534d.js"],"component---src-pages-osa-4-js":["/component---src-pages-osa-4-js.b8658faab52da8be69f9.css","/component---src-pages-osa-4-js-088ab9adfd67fa602964.js"],"component---src-pages-osa-5-js":["/component---src-pages-osa-5-js.b8658faab52da8be69f9.css","/component---src-pages-osa-5-js-1d2b2336913251264af9.js"],"component---src-pages-osa-6-js":["/component---src-pages-osa-6-js.b8658faab52da8be69f9.css","/component---src-pages-osa-6-js-1114c8fcf3edaff242ce.js"],"component---src-pages-osa-7-js":["/component---src-pages-osa-7-js.b8658faab52da8be69f9.css","/component---src-pages-osa-7-js-e06c5739a667540a2af6.js"]};/*]]>*/</script><script src="/webpack-runtime-5db535bfaadb9bdad9b8.js" async=""></script><script src="/app-ea23b7086a93b0204497.js" async=""></script><script src="/2-a8e181bf0eaee510a2de.js" async=""></script><script src="/component---src-templates-content-template-js-1511b04e7342894ff772.js" async=""></script></body></html>